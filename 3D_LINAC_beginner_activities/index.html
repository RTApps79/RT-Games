<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Integrated LINAC Alignment Simulator & Training</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<style>
body { margin: 0; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
canvas { display: block; }

/* --- UI Panels --- */
.ui-panel {
position: absolute; top: 20px; width: 340px; background: rgba(247,247,247,0.9);
border: 1px solid #ccc; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.18);
z-index: 100; display: flex; flex-direction: column; backdrop-filter: blur(2px);
transition: transform 0.4s ease-in-out;
}
.ui-header { padding: 10px; background: #ececec; font-weight: 700; cursor: move;
border-top-left-radius: 10px; border-top-right-radius: 10px; border-bottom: 1px solid #dcdcdc; text-align: center; }
.ui-content { padding: 12px; max-height: 80vh; overflow-y: auto; }
.ui-content button { display: block; width: 100%; margin: 6px 0; padding: 8px 12px; font-size: 14px; cursor: pointer; }
.ui-content strong { display: block; margin-top: 10px; margin-bottom: 6px; }

/* Console Specifics */
#console-window { right: 20px; }
#console-window.hidden { transform: translateX(calc(100% + 40px)); }

/* Alignment & Learning Specifics */
#left-panel-container {
position: absolute;
top: 20px;
left: 20px;
width: 340px;
z-index: 100;
transition: transform 0.4s ease-in-out;
}
#left-panel-container.hidden { transform: translateX(calc(-100% - 40px)); }

.tab-buttons { display: flex; border-bottom: 1px solid #ccc; }
.tab-button { flex: 1; padding: 10px; background: #e0e0e0; border: none; cursor: pointer; font-weight: bold; border-top-left-radius: 10px; border-top-right-radius: 10px; }
.tab-button.active { background: #f7f7f7; border-bottom: 1px solid #f7f7f7; margin-bottom: -1px; }
.tab-content { display: none; }
.tab-content.active { display: block; }

#align-content .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 6px; }
#align-content .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 6px; }
#align-content .row-iso { display: grid; grid-template-columns: 20px 1fr 50px; gap: 5px; align-items: center; margin-bottom: 4px; }
#align-content .row-iso label { font-weight: bold; }
#align-content .row-iso input { width: 100%; padding: 4px; border: 1px solid #ccc; border-radius: 4px; }
#align-content button { width: 100%; padding: 8px 12px; font-size: 13px; cursor: pointer; }
#alignmentMessage { font-weight: 600; min-height: 2.2em; margin-top: 8px; }

/* --- Digital Readouts --- */
.readout-grid { display: grid; grid-template-columns: auto 1fr; gap: 4px 10px; background: #e9e9e9; padding: 8px; border-radius: 6px; font-size: 13px;
font-family: 'Courier New', Courier, monospace; }
.readout-label { font-weight: bold; text-align: right; }
.readout-value { background: #fff; padding: 2px 5px; border-radius: 3px; border: 1px solid #ddd; }

/* --- Console Toggle Button --- */
#console-toggle-button { position: absolute; top: 20px; right: 360px; width: 40px; height: 40px; background: #333; color: white; border: none;
border-radius: 10px 0 0 10px; cursor: pointer; z-index: 101; display: flex; align-items: center; justify-content: center; font-size: 20px;
transition: right 0.4s ease-in-out, background-color 0.2s; }
#console-toggle-button:hover { background: #555; }

/* --- Learning Center --- */
#learning-content .module-button { background-color: #f0f0f0; border: 1px solid #ccc; }
#learning-content .module-button:hover { background-color: #e0e0e0; }
#activity-view { margin-top: 15px; }
#activity-title { font-size: 1.1em; font-weight: bold; margin-bottom: 5px; }
#activity-objective { font-size: 0.9em; margin-bottom: 10px; color: #555; }
#activity-instruction { font-size: 1em; font-weight: bold; color: #005a9c; min-height: 40px; background: #e3f2fd; padding: 8px; border-radius: 4px; border: 1px solid #bbdefb;
}
#activity-feedback { min-height: 2em; margin-top: 10px; font-weight: bold; }
#activity-progress-bar { width: 100%; background-color: #e0e0e0; border-radius: 5px; overflow: hidden; height: 10px; margin-top: 10px; }
#activity-progress { width: 0%; height: 100%; background-color: #4caf50; transition: width 0.3s; }

/* Floating labels for parts */
.component-label { position: absolute; background: rgba(0,0,0,0.7); color: #fff; padding: 3px 7px; border-radius: 4px; font-size: 12px; pointer-events: none; transform: translate(-50%, -110%);
white-space: nowrap; z-index: 5; visibility: hidden; }
#label-axisX { color: #FF7777; } #label-axisY { color: #77FF77; } #label-axisZ { color: #7777FF; }

/* Legend pill */
#legend { position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%); background: rgba(255,255,255,0.9); border: 1px solid #ddd; border-radius: 999px;
padding: 6px 12px; font-size: 13px; box-shadow: 0 4px 10px rgba(0,0,0,0.12); z-index: 50; }
.dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }
</style>

<script type="importmap">
{ "imports": { "three": "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js", "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/controls/OrbitControls.js" } }
</script>
</head>
<body>
<button id="console-toggle-button">«</button>

<div id="console-window" class="ui-panel">
<div id="console-header" class="ui-header">LINAC Console</div>
<div id="console-content" class="ui-content">
<strong>Digital Readouts</strong>
<div class="readout-grid">
<div class="readout-label">Gantry:</div><div id="readout-gantry" class="readout-value">0.0°</div>
<div class="readout-label">FS X:</div><div id="readout-jawX" class="readout-value">0.0 cm</div>
<div class="readout-label">FS Y:</div><div id="readout-jawY" class="readout-value">0.0 cm</div>
<div class="readout-label">Couch Vrt:</div><div id="readout-couchY" class="readout-value">0.0 cm</div>
<div class="readout-label">Couch Lng:</div><div id="readout-couchZ" class="readout-value">0.0 cm</div>
<div class="readout-label">Couch Lat:</div><div id="readout-couchX" class="readout-value">0.0 cm</div>
</div>
<hr>
<strong>Gantry</strong>
<button onclick="rotateGantry(true)">Rotate Gantry → (CW)</button>
<button onclick="rotateGantry(false)">Rotate Gantry ← (CCW)</button>
<hr>
<strong>Collimator</strong>
<button onclick="adjustJaws(true)">Open Jaws</button>
<button onclick="adjustJaws(false)">Close Jaws</button>
<hr>
<strong>Couch</strong>
<button onclick="moveCouch(true)">Couch ↑ (+Y)</button>
<button onclick="moveCouch(false)">Couch ↓ (-Y)</button>
<button onclick="moveCouchLongitudinal(true)">Couch In (+Z)</button>
<button onclick="moveCouchLongitudinal(false)">Couch Out (-Z)</button>
<button onclick="moveCouchLateral(false)">Couch &larr; (−X)</button>
<button onclick="moveCouchLateral(true)">Couch &rarr; (+X)</button>
<hr>
<strong>Imaging</strong>
<button id="detectorToggleButton" onclick="toggleDetector()">Extend MV Imager</button>
<button id="sideDetectorToggleButton" onclick="toggleSideDetector()">Extend kV Imagers</button>
<hr>
<strong>Accessories</strong>
<button id="coneToggleButton" onclick="toggleElectronCone()">Attach Electron Cone</button>
<hr>
<button onclick="toggleLabels()">Toggle Labels</button>
</div>
</div>

<div id="left-panel-container">
<div class="ui-panel">
<div class="tab-buttons">
<button class="tab-button active" onclick="openTab(event, 'learning-tab')">Learning Center</button>
<button class="tab-button" onclick="openTab(event, 'align-tab')">Alignment</button>
</div>
<div id="learning-tab" class="tab-content active">
<div id="learning-content" class="ui-content">
<strong>Beginner Activities</strong>
<p style="font-size:13px; margin-top:0; color:#555;">Select a module to begin a self-guided activity.</p>
<button class="module-button" onclick="LearningModule.startActivity('scavengerHunt')">1. Machine Anatomy Scavenger Hunt</button>
<button class="module-button" onclick="LearningModule.startActivity('coordinates')">2. Understanding Machine Coordinates</button>
<button class="module-button" onclick="LearningModule.startActivity('alignment')">3. Basic Patient Alignment</button>
<div id="activity-view" style="display:none;">
<hr>
<h3 id="activity-title"></h3>
<p id="activity-objective"></p>
<div id="activity-instruction"></div>
<div id="activity-feedback"></div>
<div id="activity-progress-bar"><div id="activity-progress"></div></div>
<button onclick="LearningModule.exitActivity()" style="margin-top:10px; background-color: #f44336; color:white;">Exit Activity</button>
</div>
</div>
</div>
<div id="align-tab" class="tab-content">
<div id="align-content" class="ui-content">
<div style="font-size:12px; opacity:.9; margin-bottom:6px;">Goal: Align patient tattoos to room lasers at isocenter.</div>
<div class="row3">
<button onclick="nudgePatient(-1,0,0)">X− (Lat)</button>
<button onclick="nudgePatient(0,1,0)">Y+ (Up)</button>
<button onclick="nudgePatient(1,0,0)">X+ (Lat)</button>
</div>
<div class="row3">
<button onclick="nudgePatient(0,0,-1)">Z− (In)</button>
<button onclick="checkAlignment()">Check Alignment</button>
<button onclick="nudgePatient(0,0,1)">Z+ (Out)</button>
</div>
<hr style="margin: 10px 0;">
<div style="font-size:12px; opacity:.9; margin-bottom:6px;">Isocenter/Laser Adjustment (cm):</div>
<div class="row-iso">
<label for="isoOffsetX">X:</label>
<input type="number" id="isoOffsetX" value="0" step="0.1" onchange="updateIsocenterOffset()">
<span>cm</span>
</div>
<div class="row-iso">
<label for="isoOffsetY">Y:</label>
<input type="number" id="isoOffsetY" value="0" step="0.1" onchange="updateIsocenterOffset()">
<span>cm</span>
</div>
<div class="row-iso">
<label for="isoOffsetZ">Z:</label>
<input type="number" id="isoOffsetZ" value="0" step="0.1" onchange="updateIsocenterOffset()">
<span>cm</span>
</div>
<hr style="margin: 10px 0;">
<div class="row">
<button onclick="newCase()">New Random Case</button>
<button onclick="centerCouch()"><span>Auto‑Center Couch</span></button>
</div>
<div id="alignmentMessage">Use couch/nudge controls to bring tattoos to laser lines.</div>
</div>
</div>
</div>
</div>

<div id="label-drivestand" class="component-label">Drivestand</div>
<div id="label-connectingArm" class="component-label">Connecting Arm</div>
<div id="label-acceleratorHousing" class="component-label">Accelerator Housing</div>
<div id="label-verticalArmL" class="component-label">Vertical Arm</div>
<div id="label-head" class="component-label">Head</div>
<div id="label-couchBase" class="component-label">Couch Base</div>
<div id="label-couchTop" class="component-label">Couch Top</div>
<div id="label-couchAccordion" class="component-label">Accordion</div>
<div id="label-detectorPanel" class="component-label">MV Detector Panel</div>
<div id="label-sideDetectorPanel" class="component-label">kV Detector Panel</div>
<div id="label-kvTube" class="component-label">kV X-Ray Tube</div>
<div id="label-electronCone" class="component-label">Electron Cone</div>
<div id="label-axisX" class="component-label">X</div>
<div id="label-axisY" class="component-label">Y</div>
<div id="label-axisZ" class="component-label">Z</div>
<div id="label-electronGun" class="component-label">Electron Gun</div>
<div id="label-waveguide" class="component-label">Waveguide (Acc.)</div>
<div id="label-target" class="component-label">Target</div>
<div id="label-klystron" class="component-label">Klystron</div>
<div id="label-klystronWaveguide" class="component-label">Waveguide (Klystron)</div>

<div id="legend">
<span class="dot" style="background:#ff0000"></span>Room Lasers (Red)
&nbsp;&nbsp; <span class="dot" style="background:#00ff00"></span>Tattoos (Green)
&nbsp;&nbsp; <span class="dot" style="background:#8B0000"></span>Tumor (Maroon)
</div>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

// ===== Core Scene =====
let camera, scene, renderer, controls;

// LINAC & Couch
let gantryRotatingAssembly;
let drivestand, connectingArm, acceleratorHousing, verticalArmL, head;
let couchGroup, couchSupportBase, couchAccordion, couchAccordionVisual, couchTopGroup, couchPlatform;
let initialCouchY; // For readout calculation

// Imaging
let detectorPanel, detectorArm, detectorExtended = false;
let sideDetectorPanel, sideDetectorArm, sideDetectorShortArm, sideDetectorExtended = false;
let kvTubeGroup, kvTubeHousing, kvTubeHead, kvTubeArm, kvTubeShortArm;

// Beam shaping & accessories
let jawXN, jawXP, jawYN, jawYP, headSize = 0.6, jawOffset = 0.1;
let electronCone, isConeAttached = false;

// Power & RF
let electronGun, waveguide, target, klystron;
let wgStaticVert, wgStaticHoriz, wgRotatingVert, wgRotatingHoriz;

// Patient model & alignment
let patientModel, tumor, tattooAnterior, tattooLeft, tattooRight;
const patientMat = new THREE.MeshStandardMaterial({ color: 0xAD8C74, transparent: false, opacity: 1 });
const tattooMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false });
const tumorMat  = new THREE.MeshStandardMaterial({ color: 0x8B0000, depthTest: false, transparent: true, opacity: 0.85 });

// Lasers
let laserX, laserY, laserZ;

// UI & Readouts
const alignmentMessageElement = document.getElementById('alignmentMessage');
let readoutGantry, readoutJawX, readoutJawY, readoutCouchX, readoutCouchY, readoutCouchZ;

// Labels
const labels = {};
const labeledObjects = [];
let labelsVisible = false;

// Geometry/layout constants
const isocenterYTarget = 1.5;
const gantryPlaneZTarget = -1.0;
const couchSeparationOffset = 3.5;
const couchWidth = 0.8;
const couchPlatformHeight = 0.15;
const couchLength = 3.2;
const couchBaseHeight = 0.7;
const groundY = -0.05;
const newVerticalArmTotalLength = 1.6;
const verticalArmLSize = 0.4;
const acceleratorHousingLength = 2.0;
const detectorPanelWidth = 0.7, detectorPanelHeight = 0.6, detectorPanelThickness = 0.05, detectorArmRadius = 0.03;
const accordionGeometricHeight = 1.0;

// Alignment state
const MOVE_STEP = 0.001; // meters for fine nudge
const ALIGNMENT_TOLERANCE = 0.01; // 1 cm
let tumorLocalOffset = new THREE.Vector3();

// Isocenter vectors
let machineIsocenter = new THREE.Vector3(); // The "true" isocenter of the machine
let laserIsocenter = new THREE.Vector3();   // The position of the lasers, adjustable by user
let isocenterOffset = new THREE.Vector3();  // User-defined offset in meters

// Materials
const lightGrayMat = new THREE.MeshStandardMaterial({ color: 0xd3d3d3 });
const lightBlueMat = new THREE.MeshStandardMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.5 });
const brightOrangeMat = new THREE.MeshStandardMaterial({ color: 0xffa500 });
const brightCyanMat = new THREE.MeshStandardMaterial({ color: 0x00ffff });
const transparentLightGrayMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, transparent: true, opacity: 0.55 });
const lightBeigeMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc });
const mediumGrayMat = new THREE.MeshStandardMaterial({ color: 0x909090 });
const darkGrayMatMaterial = new THREE.MeshStandardMaterial({ color: 0x505050 });
const metallicGrayMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.5, roughness: 0.5 });
const targetMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8, roughness: 0.3 });
const klystronMat = new THREE.MeshStandardMaterial({ color: 0x778899, metalness: 0.3, roughness: 0.6 });
const klystronWaveguideMat = new THREE.MeshStandardMaterial({ color: 0xb8860b, metalness: 0.7, roughness: 0.4 });
const drivestandMaterial = new THREE.MeshStandardMaterial({ color: 0xeee8aa, transparent: true, opacity: 0.35, depthWrite: false });

// ===== LEARNING MODULE (Moved to top to prevent initialization error) =====
const LearningModule = {
currentActivity: null,
currentStep: 0,
isChecking: false, // Flag to prevent rapid-fire checks
clicksDone: 0,
activities: {
scavengerHunt: {
title: "Anatomy Scavenger Hunt",
objective: "To identify major LINAC components by clicking on them.",
steps: [
{ instruction: "Find and click on the: Klystron", target: "Klystron" },
{ instruction: "Find and click on the: Accelerator Housing", target: "Accelerator Housing" },
{ instruction: "Find and click on the: Treatment Head", target: "Head" }, // FIX: Changed "Treatment Head" to "Head"
{ instruction: "Find and click on the: MV Detector Panel", target: "MV Detector Panel" }
]
},
coordinates: {
title: "Machine Coordinates",
objective: "To understand couch movements and their clinical terms.",
steps: [
{ instruction: "Move the couch IN (Superior) 3 times", target: { axis: 'Z', direction: true, clicksRequired: 3 } },
{ instruction: "Move the couch OUT (Inferior) 3 times", target: { axis: 'Z', direction: false, clicksRequired: 3 } },
{ instruction: "Move the couch RIGHT (Patient's Right) 3 times", target: { axis: 'X', direction: true, clicksRequired: 3 } },
{ instruction: "Move the couch LEFT (Patient's Left) 3 times", target: { axis: 'X', direction: false, clicksRequired: 3 } },
{ instruction: "Move the couch UP (Anterior) 3 times", target: { axis: 'Y', direction: true, clicksRequired: 3 } },
{ instruction: "Move the couch DOWN (Posterior) 3 times", target: { axis: 'Y', direction: false, clicksRequired: 3 } }
]
},
alignment: {
title: "Basic Patient Alignment",
objective: "To align the patient tattoos to the room lasers.",
steps: [ { instruction: "Click 'New Random Case', then use the couch controls to align the green tattoos to the red lasers. Click 'Check Alignment' when done."
} ]
}
},

startActivity(activityName) {
this.currentActivity = this.activities[activityName];
this.currentStep = 0;
this.clicksDone = 0;
document.getElementById('activity-view').style.display = 'block';
document.getElementById('activity-title').textContent = this.currentActivity.title;
document.getElementById('activity-objective').textContent = this.currentActivity.objective;
this.updateStep();

if (activityName === 'scavengerHunt') {
toggleLabels(false); // Force labels OFF for the hunt
renderer.domElement.addEventListener('click', this.onCanvasClick, false);
}
},

exitActivity() {
document.getElementById('activity-view').style.display = 'none';
this.currentActivity = null;
renderer.domElement.removeEventListener('click', this.onCanvasClick, false);
},

updateStep() {
if (!this.currentActivity) return;
this.clicksDone = 0; // Reset click count for the new step
const progress = (this.currentStep / this.currentActivity.steps.length) * 100;
document.getElementById('activity-progress').style.width = `${progress}%`;

if (this.currentStep >= this.currentActivity.steps.length) {
this.completeActivity();
return;
}

const step = this.currentActivity.steps[this.currentStep];
document.getElementById('activity-instruction').textContent = step.instruction;
this.setFeedback("", "black");
},

advanceStep() {
if (this.isChecking) return;
this.isChecking = true;
this.setFeedback("Correct!", "green");
this.currentStep++;
setTimeout(() => {
this.isChecking = false;
this.updateStep();
}, 1000);
},

completeActivity() {
document.getElementById('activity-instruction').textContent = "Module Complete!";
document.getElementById('activity-progress').style.width = `100%`;
this.setFeedback("Excellent work!", "green");
renderer.domElement.removeEventListener('click', this.onCanvasClick, false);
},

setFeedback(text, color) {
const feedbackEl = document.getElementById('activity-feedback');
feedbackEl.textContent = text;
feedbackEl.style.color = color;
},

onCanvasClick: (event) => {
    if (LearningModule.isChecking || !LearningModule.currentActivity || LearningModule.currentActivity.title !== 'Anatomy Scavenger Hunt') return;

    const step = LearningModule.currentActivity.steps[LearningModule.currentStep];
    if (!step) return;

    const mouse = new THREE.Vector2();
    mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
    mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

    const raycaster = new THREE.Raycaster();
    raycaster.setFromCamera(mouse, camera);

    const intersects = raycaster.intersectObjects(scene.children, true);
    let found = false;

    if (intersects.length > 0) {
        // Loop through ALL intersected objects, not just the first one.
        // This is crucial for clicking through transparent objects.
        for (const intersect of intersects) {
            let clickedObject = intersect.object;
            // Also, loop up the parent hierarchy for each intersected object
            while (clickedObject) {
                const labeledInfo = labeledObjects.find(item => item.object === clickedObject);
                if (labeledInfo && labeledInfo.name === step.target) {
                    LearningModule.advanceStep();
                    found = true;
                    break; // Exit the parent-tree (while) loop
                }
                clickedObject = clickedObject.parent;
            }
            if (found) {
                break; // Exit the main intersections (for) loop
            }
        }
    }

    if (!found) {
        LearningModule.setFeedback("Not quite. Keep looking!", "crimson");
    }
},

checkCoordinateSuccess(axis, positive) {
if (this.isChecking || !this.currentActivity || this.currentActivity.title !== 'Machine Coordinates') return;
const step = this.currentActivity.steps[this.currentStep];
if (step && step.target.axis === axis && step.target.direction === positive) {
this.clicksDone++;
const instructionEl = document.getElementById('activity-instruction');
instructionEl.textContent = `${step.instruction.split('(')[0]} (${this.clicksDone}/${step.target.clicksRequired})`;
if (this.clicksDone >= step.target.clicksRequired) {
this.advanceStep();
}
}
},

checkAlignmentSuccess() {
if (!this.currentActivity || this.currentActivity.title !== 'Basic Patient Alignment') return;
const dist = tumor.getWorldPosition(new THREE.Vector3()).distanceTo(laserIsocenter);
if (dist < ALIGNMENT_TOLERANCE) {
this.advanceStep();
}
}
};
window.LearningModule = LearningModule; // Expose to global scope

// ===== Init =====
init();
animate();

function init() {
// Scene
scene = new THREE.Scene();
scene.background = new THREE.Color(0xf0f0f0);

// Camera
camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 120);

// Renderer
renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;
document.body.appendChild(renderer.domElement);

// Controls
controls = new OrbitControls(camera, renderer.domElement);
controls.enableDamping = true; controls.dampingFactor = 0.08;
controls.maxPolarAngle = Math.PI / 2;

// Lights
scene.add(new THREE.AmbientLight(0x808080));
const dir = new THREE.DirectionalLight(0xffffff, 0.7);
dir.position.set(15, 20, 15);
dir.castShadow = true; dir.shadow.mapSize.set(2048,2048); scene.add(dir);

// Ground
const groundPlane = new THREE.Mesh(
new THREE.PlaneGeometry(40, 40),
new THREE.MeshStandardMaterial({ color: 0xe0e0e0, side: THREE.DoubleSide })
);
groundPlane.rotation.x = -Math.PI / 2;
groundPlane.position.y = groundY;
groundPlane.receiveShadow = true;
scene.add(groundPlane);

// Axes
const axisLen = 3; const origin = new THREE.Vector3();
scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([origin, new THREE.Vector3(axisLen,0,0)]), new THREE.LineBasicMaterial({ color: 0xff0000 })));
scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([origin, new THREE.Vector3(0,axisLen,0)]), new THREE.LineBasicMaterial({ color: 0x00ff00 })));
scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([origin, new THREE.Vector3(0,0,axisLen)]), new THREE.LineBasicMaterial({ color: 0x0000ff })));

// Gantry assembly
buildGantry();

// Couch
buildCouch();

// Patient
buildPatient();

// Lasers
buildLasers();
updateIsocenterOffset();

// Camera
camera.position.set(8, isocenterYTarget + 3, machineIsocenter.z + 9);
camera.lookAt(0, isocenterYTarget, machineIsocenter.z);
controls.target.set(0, isocenterYTarget, machineIsocenter.z);
controls.update();

// Labels
hookLabels();

// UI
setupUI();

// Window events
window.addEventListener('resize', onWindowResize);

// First case
newCase();
}

// ---- Build Gantry/LINAC ----
function buildGantry() {
const gantrySetupGroup = new THREE.Group();
gantrySetupGroup.position.set(0, 0, gantryPlaneZTarget);
scene.add(gantrySetupGroup);

const drivestandHeight = isocenterYTarget + 0.3;
const drivestandDepth = 0.8;
drivestand = new THREE.Mesh(new THREE.BoxGeometry(0.8, drivestandHeight, drivestandDepth), drivestandMaterial);
const visualGap = 0.4;
drivestand.position.set(0, (drivestandHeight / 2) + groundY, -(visualGap + drivestandDepth / 2));
gantrySetupGroup.add(drivestand);
enableShadows(drivestand);

connectingArm = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.3, visualGap), lightGrayMat);
connectingArm.position.set(0, isocenterYTarget, -visualGap / 2);
gantrySetupGroup.add(connectingArm);
enableShadows(connectingArm);

gantryRotatingAssembly = new THREE.Group();
gantryRotatingAssembly.position.set(0, isocenterYTarget, 0);
gantrySetupGroup.add(gantryRotatingAssembly);
enableShadows(gantryRotatingAssembly);
window.gantryRotatingAssembly = gantryRotatingAssembly;

verticalArmL = new THREE.Mesh(new THREE.BoxGeometry(verticalArmLSize, newVerticalArmTotalLength, verticalArmLSize), lightBlueMat);
gantryRotatingAssembly.add(verticalArmL);

acceleratorHousing = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.5, acceleratorHousingLength), lightBlueMat);
acceleratorHousing.position.set(0, newVerticalArmTotalLength / 2, acceleratorHousingLength / 2);
gantryRotatingAssembly.add(acceleratorHousing);

head = new THREE.Mesh(new THREE.BoxGeometry(headSize, headSize, headSize), transparentLightGrayMat);
head.position.set(0, newVerticalArmTotalLength / 2, acceleratorHousingLength);
gantryRotatingAssembly.add(head);

head.updateWorldMatrix(true, false);
machineIsocenter = head.getWorldPosition(new THREE.Vector3());
machineIsocenter.y -= newVerticalArmTotalLength / 2;

const gunLength = 0.3, gunRadius = 0.15;
electronGun = new THREE.Mesh(new THREE.CylinderGeometry(gunRadius, gunRadius * 0.8, gunLength, 16), metallicGrayMat);
electronGun.rotation.x = Math.PI / 2;
electronGun.position.set(0, 0, -acceleratorHousingLength / 2 - gunLength / 2);
acceleratorHousing.add(electronGun);
enableShadows(electronGun);

const waveguideRadius = 0.05;
const waveguideLength = acceleratorHousingLength - gunLength - 0.1;
waveguide = new THREE.Mesh(new THREE.CylinderGeometry(waveguideRadius, waveguideRadius, waveguideLength, 16), metallicGrayMat);
waveguide.rotation.x = Math.PI / 2;
waveguide.position.set(0, 0, electronGun.position.z + gunLength / 2 + waveguideLength / 2);
acceleratorHousing.add(waveguide);
enableShadows(waveguide);

const targetRadius = 0.08, targetThickness = 0.02;
target = new THREE.Mesh(new THREE.CylinderGeometry(targetRadius, targetRadius, targetThickness, 16), targetMat);
target.rotation.x = Math.PI / 2;
target.position.set(0, 0, 0.1);
head.add(target);
enableShadows(target);

const jawsGroup = new THREE.Group();
head.add(jawsGroup);
const jawThickness = 0.06;
const jawDepth = 0.3;
const jawSpan = headSize * 0.8;
jawXN = new THREE.Mesh(new THREE.BoxGeometry(jawThickness, jawSpan, jawDepth), brightOrangeMat);
jawXP = new THREE.Mesh(new THREE.BoxGeometry(jawThickness, jawSpan, jawDepth), brightOrangeMat);
jawYN = new THREE.Mesh(new THREE.BoxGeometry(jawSpan, jawThickness, jawDepth), brightCyanMat);
jawYP = new THREE.Mesh(new THREE.BoxGeometry(jawSpan, jawThickness, jawDepth), brightCyanMat);
jawsGroup.add(jawXN, jawXP, jawYN, jawYP);
setJawOffset(jawOffset);

detectorArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), lightGrayMat);
detectorPanel = new THREE.Mesh(new THREE.BoxGeometry(detectorPanelWidth, detectorPanelHeight, detectorPanelThickness), lightGrayMat);
gantryRotatingAssembly.add(detectorArm, detectorPanel);
setDetectorState(false);

const shortArmGeo = new THREE.BoxGeometry(0.15, 0.2, 0.15);
sideDetectorShortArm = new THREE.Mesh(shortArmGeo, mediumGrayMat);
kvTubeShortArm = new THREE.Mesh(shortArmGeo, mediumGrayMat);
const kvOffset = 0.45;
sideDetectorShortArm.position.set(-(verticalArmLSize / 2 + kvOffset), 0, 0);
kvTubeShortArm.position.set(verticalArmLSize / 2 + kvOffset, 0, 0);
gantryRotatingAssembly.add(sideDetectorShortArm, kvTubeShortArm);

sideDetectorPanel = new THREE.Mesh(new THREE.BoxGeometry(detectorPanelWidth, detectorPanelHeight, detectorPanelThickness), lightGrayMat);
sideDetectorArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), lightGrayMat);
gantryRotatingAssembly.add(sideDetectorPanel, sideDetectorArm);

kvTubeGroup = new THREE.Group();
kvTubeHousing = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.5, 20), metallicGrayMat);
kvTubeHead = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.1, 20), mediumGrayMat);
kvTubeHead.position.y = 0.25;
kvTubeGroup.add(kvTubeHousing, kvTubeHead);
kvTubeArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), lightGrayMat);
gantryRotatingAssembly.add(kvTubeGroup, kvTubeArm);
setSideDetectorState(false);

const coneMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, transparent: true, opacity: 0.6 });
const coneHeight = 0.8;
const coneSize = headSize * 0.7;
electronCone = new THREE.Mesh(new THREE.BoxGeometry(coneSize, coneHeight, coneSize), coneMaterial);
electronCone.position.set(0, -(headSize / 2) - (coneHeight / 2), 0);
head.add(electronCone);
electronCone.visible = false;

const klystronHeight = 0.6;
klystron = new THREE.Mesh(new THREE.BoxGeometry(0.4, klystronHeight, 0.4), klystronMat);
klystron.position.set(drivestand.position.x, (drivestand.position.y - drivestandHeight / 2) + klystronHeight / 2, drivestand.position.z);
gantrySetupGroup.add(klystron);
enableShadows(klystron);

const klystronWaveguideRadius = 0.04;
const wgStatic_Y_Start = klystron.position.y + klystronHeight / 2;
const wgStatic_Y_End = connectingArm.position.y;
const wgStatic_Vert_Length = Math.abs(wgStatic_Y_End - wgStatic_Y_Start);
wgStaticVert = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, wgStatic_Vert_Length > 0 ? wgStatic_Vert_Length : 0.01, 16), klystronWaveguideMat);
wgStaticVert.position.set(klystron.position.x, wgStatic_Y_Start + wgStatic_Vert_Length / 2, klystron.position.z);
gantrySetupGroup.add(wgStaticVert);

const wgStatic_Z_Start = klystron.position.z;
const wgStatic_Z_End = connectingArm.position.z + visualGap / 2;
const wgStatic_Horiz_Length = Math.abs(wgStatic_Z_End - wgStatic_Z_Start);
wgStaticHoriz = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, wgStatic_Horiz_Length > 0 ? wgStatic_Horiz_Length : 0.01, 16), klystronWaveguideMat);
wgStaticHoriz.rotation.x = Math.PI / 2;
wgStaticHoriz.position.set(klystron.position.x, wgStatic_Y_End, wgStatic_Z_Start + (wgStatic_Z_End - wgStatic_Z_Start) / 2);
gantrySetupGroup.add(wgStaticHoriz);

const eg_local_y = newVerticalArmTotalLength / 2;
const wgRotating_Vert_Length = eg_local_y;
wgRotatingVert = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, wgRotating_Vert_Length > 0 ? wgRotating_Vert_Length : 0.01, 16), klystronWaveguideMat);
wgRotatingVert.position.set(0, wgRotating_Vert_Length / 2, 0);
gantryRotatingAssembly.add(wgRotatingVert);

const electronGunWorldPos = new THREE.Vector3();
acceleratorHousing.updateMatrixWorld(true);
electronGun.getWorldPosition(electronGunWorldPos);
const electronGunLocalPosGRA = gantryRotatingAssembly.worldToLocal(electronGunWorldPos.clone());
const wgRotating_Horiz_Z_Start = 0;
const wgRotating_Horiz_Z_End = electronGunLocalPosGRA.z;
const wgRotating_Horiz_Length_Actual = Math.abs(wgRotating_Horiz_Z_End - wgRotating_Horiz_Z_Start);
wgRotatingHoriz = new THREE.Mesh(new THREE.CylinderGeometry(klystronWaveguideRadius, klystronWaveguideRadius, wgRotating_Horiz_Length_Actual > 0 ? wgRotating_Horiz_Length_Actual : 0.01, 16), klystronWaveguideMat);
wgRotatingHoriz.rotation.x = Math.PI / 2;
wgRotatingHoriz.position.set(0, eg_local_y, (wgRotating_Horiz_Z_Start + wgRotating_Horiz_Z_End) / 2);
gantryRotatingAssembly.add(wgRotatingHoriz);
}

// ---- Couch ----
function buildCouch() {
couchGroup = new THREE.Group(); window.couchGroup = couchGroup;
initialCouchY = (couchBaseHeight/2) + groundY;
couchGroup.position.set(0, initialCouchY, gantryPlaneZTarget + couchSeparationOffset);
scene.add(couchGroup); enableShadows(couchGroup);

couchSupportBase = new THREE.Mesh(new THREE.BoxGeometry(couchWidth * 0.8, couchBaseHeight, couchLength * 0.5), lightBeigeMat);
couchSupportBase.position.y = 0; couchGroup.add(couchSupportBase);

couchTopGroup = new THREE.Group(); window.couchTopGroup = couchTopGroup;
couchTopGroup.position.y = (couchBaseHeight/2) + (couchPlatformHeight/2); couchTopGroup.position.z = 0; couchGroup.add(couchTopGroup);

couchPlatform = new THREE.Mesh(new THREE.BoxGeometry(couchWidth, couchPlatformHeight, couchLength), mediumGrayMat);
couchTopGroup.add(couchPlatform);

couchAccordion = new THREE.Group(); couchAccordion.position.set(couchGroup.position.x, groundY, couchGroup.position.z); scene.add(couchAccordion); enableShadows(couchAccordion);
couchAccordionVisual = new THREE.Mesh(new THREE.BoxGeometry(couchWidth * 0.7, accordionGeometricHeight, couchLength * 0.4), darkGrayMatMaterial);
couchAccordionVisual.position.y = accordionGeometricHeight/2; couchAccordion.add(couchAccordionVisual); updateAccordion();
}

// ---- Patient Model ----
function buildPatient() {
patientModel = new THREE.Group();
couchTopGroup.add(patientModel);

const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.26, 0.75, 20), patientMat); torso.castShadow = true; patientModel.add(torso);
const neck  = new THREE.Mesh(new THREE.CylinderGeometry(0.10, 0.10, 0.12, 16), patientMat); neck.position.set(0, 0.75/2 + 0.08, 0); patientModel.add(neck);
const headS = new THREE.Mesh(new THREE.SphereGeometry(0.14, 20, 20), patientMat); headS.position.set(0, neck.position.y + 0.12, 0); headS.scale.set(0.8, 1, 1); patientModel.add(headS);
const armGeo = new THREE.CylinderGeometry(0.07, 0.06, 0.70, 12);
const leftArm = new THREE.Mesh(armGeo, patientMat); leftArm.position.set(-0.32, 0.0, 0); patientModel.add(leftArm);
const rightArm= new THREE.Mesh(armGeo, patientMat); rightArm.position.set( 0.32, 0.0, 0); patientModel.add(rightArm);
const legGeo = new THREE.CylinderGeometry(0.12, 0.09, 0.85, 12);
const leftLeg = new THREE.Mesh(legGeo, patientMat); leftLeg.position.set(-0.12, -0.85, 0); patientModel.add(leftLeg);
const rightLeg= new THREE.Mesh(legGeo, patientMat); rightLeg.position.set( 0.12, -0.85, 0); patientModel.add(rightLeg);

tumor = new THREE.Mesh(new THREE.SphereGeometry(0.05, 24, 24), tumorMat); tumor.renderOrder = 2; patientModel.add(tumor);
const tatGeo = new THREE.SphereGeometry(0.012, 12, 12);
tattooAnterior = new THREE.Mesh(tatGeo, tattooMat); tattooLeft = new THREE.Mesh(tatGeo, tattooMat); tattooRight = new THREE.Mesh(tatGeo, tattooMat);
[tattooAnterior, tattooLeft, tattooRight].forEach(t => { t.renderOrder = 3; patientModel.add(t); });

patientModel.rotation.x = -Math.PI/2;
const patientOnCouchY = (couchPlatformHeight / 2) + 0.28 + 0.01;
patientModel.position.set(0, patientOnCouchY, -0.3);
}

// ---- Room Lasers ----
function buildLasers() {
const laserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, depthTest: false, transparent: true, opacity: 0.95 });
const laserLen = 30, laserRadius = 0.01;
const geo = new THREE.CylinderGeometry(laserRadius, laserRadius, laserLen, 8);

laserX = new THREE.Mesh(geo, laserMaterial); laserX.rotation.z = Math.PI/2; scene.add(laserX);
laserY = new THREE.Mesh(geo, laserMaterial); scene.add(laserY);
laserZ = new THREE.Mesh(geo, laserMaterial); laserZ.rotation.x = Math.PI/2; scene.add(laserZ);
[laserX, laserY, laserZ].forEach(l => { l.renderOrder = 10; });
}

// ---- Labels ----
function hookLabels() {
const ids = ['drivestand','connectingArm','acceleratorHousing','verticalArmL','head','couchBase','couchTop','couchAccordion','detectorPanel','sideDetectorPanel','kvTube','electronCone','axisX','axisY','axisZ','electronGun','waveguide','target','klystron','klystronWaveguide'];
ids.forEach(id => labels[id] = document.getElementById('label-'+id));

const xAxisLabelObj = new THREE.Object3D(); xAxisLabelObj.position.set(3.2,0,0); scene.add(xAxisLabelObj);
const yAxisLabelObj = new THREE.Object3D(); yAxisLabelObj.position.set(0,3.2,0); scene.add(yAxisLabelObj);
const zAxisLabelObj = new THREE.Object3D(); zAxisLabelObj.position.set(0,0,3.2); scene.add(zAxisLabelObj);

labeledObjects.push({ object: drivestand, label: labels.drivestand, name: 'Drivestand' });
labeledObjects.push({ object: connectingArm, label: labels.connectingArm, name: 'Connecting Arm' });
labeledObjects.push({ object: acceleratorHousing, label: labels.acceleratorHousing, name: 'Accelerator Housing' });
labeledObjects.push({ object: verticalArmL, label: labels.verticalArmL, name: 'Vertical Arm' });
labeledObjects.push({ object: head, label: labels.head, name: 'Head' });
labeledObjects.push({ object: couchSupportBase, label: labels.couchBase, name: 'Couch Base' });
labeledObjects.push({ object: couchPlatform, label: labels.couchTop, name: 'Couch Top' });
labeledObjects.push({ object: couchAccordionVisual, label: labels.couchAccordion, name: 'Accordion' });
labeledObjects.push({ object: detectorPanel, label: labels.detectorPanel, name: 'MV Detector Panel' });
labeledObjects.push({ object: sideDetectorPanel, label: labels.sideDetectorPanel, name: 'kV Detector Panel' });
labeledObjects.push({ object: kvTubeHousing, label: labels.kvTube, name: 'kV X-Ray Tube' });
labeledObjects.push({ object: electronCone, label: labels.electronCone, name: 'Electron Cone' });
labeledObjects.push({ object: xAxisLabelObj, label: labels.axisX, name: 'X-Axis' });
labeledObjects.push({ object: yAxisLabelObj, label: labels.axisY, name: 'Y-Axis' });
labeledObjects.push({ object: zAxisLabelObj, label: labels.axisZ, name: 'Z-Axis' });
labeledObjects.push({ object: electronGun, label: labels.electronGun, name: 'Electron Gun' });
labeledObjects.push({ object: waveguide, label: labels.waveguide, name: 'Waveguide (Acc.)' });
labeledObjects.push({ object: target, label: labels.target, name: 'Target' });
labeledObjects.push({ object: klystron, label: labels.klystron, name: 'Klystron' });
labeledObjects.push({ object: wgStaticHoriz, label: labels.klystronWaveguide, name: 'Waveguide (Klystron)' });

updateAllLabelVisibility();
}

// ===== Alignment logic =====
function newCase() {
tumorLocalOffset.set((Math.random()-0.5)*0.12, (Math.random()-0.2)*0.40, (Math.random()-0.5)*0.12);
tumor.position.copy(tumorLocalOffset);

const torsoParams = { height: 0.75, radiusTop: 0.28, radiusBottom: 0.26 };
const y_norm = (tumorLocalOffset.y + torsoParams.height/2) / torsoParams.height;
const radiusAtY = torsoParams.radiusBottom + (torsoParams.radiusTop - torsoParams.radiusBottom) * y_norm;
tattooAnterior.position.set(tumorLocalOffset.x, tumorLocalOffset.y, radiusAtY);
tattooLeft.position.set(-radiusAtY, tumorLocalOffset.y, tumorLocalOffset.z);
tattooRight.position.set(radiusAtY, tumorLocalOffset.y, tumorLocalOffset.z);

couchTopGroup.position.x = (Math.random()-0.5) * 0.20;
couchTopGroup.position.z = (Math.random()-0.5) * 0.30;
couchGroup.position.y    = (couchBaseHeight/2) + groundY + 0.20 + Math.random()*0.20;
constrainCouch();
updateReadouts();

alignmentMessageElement.style.color = '#333';
alignmentMessageElement.textContent = 'Use couch/nudge controls to bring tattoos to laser lines.';
LearningModule.checkAlignmentSuccess();
}

function nudgePatient(dx, dy, dz) {
couchTopGroup.position.x += dx * MOVE_STEP;
couchGroup.position.y    += dy * MOVE_STEP;
couchTopGroup.position.z += dz * MOVE_STEP;
constrainCouch();
updateReadouts();
}

function centerCouch() {
couchTopGroup.position.x = 0;
couchTopGroup.position.z = 0;

const patientSurfaceWorldY = new THREE.Vector3();
tattooAnterior.getWorldPosition(patientSurfaceWorldY);

const requiredShiftY = laserIsocenter.y - patientSurfaceWorldY.y;
couchGroup.position.y += requiredShiftY;

constrainCouch();
updateReadouts();
}

function checkAlignment() {
const tumorWorld = new THREE.Vector3(); tumor.getWorldPosition(tumorWorld);
const dist = tumorWorld.distanceTo(laserIsocenter);

const shift = new THREE.Vector3().subVectors(laserIsocenter, tumorWorld);
const isAligned = dist < ALIGNMENT_TOLERANCE;
const msg = isAligned
? `Alignment OK! Tumor at laser isocenter within ${(dist*1000).toFixed(1)} mm.`
: `Tumor is ${(dist*100).toFixed(1)} cm from laser ISO. Required Shifts → X: ${(shift.x*100).toFixed(1)} cm, Y: ${(shift.y*100).toFixed(1)} cm, Z: ${(shift.z*100).toFixed(1)} cm`;
alignmentMessageElement.innerHTML = msg;
alignmentMessageElement.style.color = isAligned ? 'green' : 'crimson';

if (isAligned) {
LearningModule.checkAlignmentSuccess();
}
}

function updateIsocenterOffset() {
const x = parseFloat(document.getElementById('isoOffsetX').value) / 100;
const y = parseFloat(document.getElementById('isoOffsetY').value) / 100;
const z = parseFloat(document.getElementById('isoOffsetZ').value) / 100;
isocenterOffset.set(x || 0, y || 0, z || 0);
laserIsocenter.copy(machineIsocenter).add(isocenterOffset);
laserX.position.copy(laserIsocenter);
laserY.position.copy(laserIsocenter);
laserZ.position.copy(laserIsocenter);
}

// ===== LINAC Interactions =====
function toggleLabels(forceState) {
labelsVisible = (forceState !== undefined) ? forceState : !labelsVisible;
if (!labelsVisible) hideAllLabels();
else updateAllLabelVisibility();
};

function rotateGantry(clockwise = true) {
const direction = clockwise ? -1 : 1;
gantryRotatingAssembly.rotation.z += direction * 0.05;
updateReadouts();
};

function adjustJaws(open = true) {
const delta = open ? 0.02 : -0.02;
setJawOffset(THREE.MathUtils.clamp(jawOffset + delta, 0.03, headSize*0.4));
updateReadouts();
};

function moveCouch(up = true) {
couchGroup.position.y += up ? 0.05 : -0.05;
constrainCouch();
updateReadouts();
LearningModule.checkCoordinateSuccess('Y', up);
};

function moveCouchLongitudinal(towardsGantry = true) {
const dir = towardsGantry ? -1 : 1; couchTopGroup.position.z += dir * 0.05;
constrainCouch();
updateReadouts();
LearningModule.checkCoordinateSuccess('Z', towardsGantry); // FIX: Removed the "!" to correct inverted logic
};

function moveCouchLateral(positive = true) {
const dir = positive ? 1 : -1; couchTopGroup.position.x += dir * 0.05; // Note: 'positive' here means +X (Right)
constrainCouch();
updateReadouts();
LearningModule.checkCoordinateSuccess('X', positive); // FIX: Removed the "!" and adjusted logic to be direct
};

function toggleDetector() { setDetectorState(!detectorExtended); }

function setDetectorState(isExtended) {
detectorExtended = isExtended;
if (isExtended) {
const isoLocal = gantryRotatingAssembly.worldToLocal(machineIsocenter.clone());
const armStartPos = new THREE.Vector3(0, -newVerticalArmTotalLength / 2, 0);
const panelPos = new THREE.Vector3(0, armStartPos.y, isoLocal.z);
const armVector = new THREE.Vector3().subVectors(panelPos, armStartPos);
const armLength = armVector.length();
detectorArm.visible = true;
detectorPanel.visible = true;
detectorArm.geometry.dispose();
detectorArm.geometry = new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, armLength, 16);
detectorArm.position.copy(armStartPos).add(armVector.clone().multiplyScalar(0.5));
detectorArm.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), armVector.clone().normalize());
detectorPanel.position.copy(panelPos);
const headWorldPos = head.getWorldPosition(new THREE.Vector3());
const gantryRight = new THREE.Vector3(1, 0, 0).applyQuaternion(gantryRotatingAssembly.quaternion);
detectorPanel.up.copy(gantryRight);
detectorPanel.lookAt(headWorldPos);
} else {
detectorArm.visible = false;
detectorPanel.visible = true;
detectorPanel.rotation.set(0, 0, 0);
detectorPanel.position.set(0, -newVerticalArmTotalLength / 2, verticalArmLSize / 2 + detectorPanelThickness / 2);
}
document.getElementById('detectorToggleButton').textContent = detectorExtended ? 'Retract MV Imager' : 'Extend MV Imager';
}

function toggleSideDetector() { setSideDetectorState(!sideDetectorExtended); }

function setSideDetectorState(isExtended) {
sideDetectorExtended = isExtended;
const allImagerParts = [sideDetectorPanel, sideDetectorArm, kvTubeGroup, kvTubeArm];
if (isExtended) {
allImagerParts.forEach(p => p.visible = true);
const isoLocal = gantryRotatingAssembly.worldToLocal(machineIsocenter.clone());
const detectorStartPos = sideDetectorShortArm.position.clone();
const detectorEndPos = new THREE.Vector3(detectorStartPos.x, detectorStartPos.y, isoLocal.z);
const detectorVector = new THREE.Vector3().subVectors(detectorEndPos, detectorStartPos);
const detectorArmLength = detectorVector.length();
sideDetectorArm.geometry.dispose();
sideDetectorArm.geometry = new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, detectorArmLength, 16);
sideDetectorArm.position.copy(detectorStartPos).add(detectorVector.clone().multiplyScalar(0.5));
sideDetectorArm.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), detectorVector.clone().normalize());
sideDetectorPanel.position.copy(detectorEndPos);
sideDetectorPanel.rotation.set(0, Math.PI / 2, 0);
const tubeStartPos = kvTubeShortArm.position.clone();
const tubeEndPos = new THREE.Vector3(tubeStartPos.x, tubeStartPos.y, isoLocal.z);
const tubeVector = new THREE.Vector3().subVectors(tubeEndPos, tubeStartPos);
const tubeArmLength = tubeVector.length();
kvTubeArm.geometry.dispose();
kvTubeArm.geometry = new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, tubeArmLength, 16);
kvTubeArm.position.copy(tubeStartPos).add(tubeVector.clone().multiplyScalar(0.5));
kvTubeArm.quaternion.setFromUnitVectors(new THREE.Vector3(0, 1, 0), tubeVector.clone().normalize());
kvTubeGroup.position.copy(tubeEndPos);
kvTubeGroup.rotation.set(Math.PI / 2, Math.PI, 0);
} else {
allImagerParts.forEach(p => p.visible = false);
}
document.getElementById('sideDetectorToggleButton').textContent = detectorExtended ? 'Retract kV Imagers' : 'Extend kV Imagers';
}

function toggleElectronCone() {
isConeAttached = !isConeAttached; electronCone.visible = isConeAttached;
document.getElementById('coneToggleButton').textContent = isConeAttached ? 'Remove Electron Cone' : 'Attach Electron Cone';
};

// ===== UI and Readouts =====
function setupUI() {
readoutGantry = document.getElementById('readout-gantry');
readoutJawX = document.getElementById('readout-jawX');
readoutJawY = document.getElementById('readout-jawY');
readoutCouchX = document.getElementById('readout-couchX');
readoutCouchY = document.getElementById('readout-couchY');
readoutCouchZ = document.getElementById('readout-couchZ');
const toggleButton = document.getElementById('console-toggle-button');
const consoleWindow = document.getElementById('console-window');
const leftPanel = document.getElementById('left-panel-container');
let panelsVisible = true;
toggleButton.addEventListener('click', () => {
panelsVisible = !panelsVisible;
consoleWindow.classList.toggle('hidden', !panelsVisible);
leftPanel.classList.toggle('hidden', !panelsVisible);
toggleButton.innerHTML = panelsVisible ? '«' : '»';
toggleButton.style.right = panelsVisible ? '360px' : '20px';
});
updateReadouts();
}

function updateReadouts() {
let gantryAngle = -(gantryRotatingAssembly.rotation.z * 180 / Math.PI);
gantryAngle = (gantryAngle % 360 + 360) % 360;
readoutGantry.textContent = `${gantryAngle.toFixed(1)}°`;
const fieldSizeX = (jawOffset * 2 * 100).toFixed(1);
const fieldSizeY = (jawOffset * 2 * 100).toFixed(1);
readoutJawX.textContent = `${fieldSizeX} cm`;
readoutJawY.textContent = `${fieldSizeY} cm`;
const couchVrt = ((couchGroup.position.y - initialCouchY) * 100).toFixed(1);
const couchLng = (couchTopGroup.position.z * 100).toFixed(1);
const couchLat = (couchTopGroup.position.x * 100).toFixed(1);
readoutCouchY.textContent = `${couchVrt} cm`;
readoutCouchZ.textContent = `${couchLng} cm`;
readoutCouchX.textContent = `${couchLat} cm`;
}

// Helpers
function setJawOffset(val){ jawOffset = val; jawXN.position.x = -jawOffset; jawXP.position.x = jawOffset; jawYN.position.y = -jawOffset; jawYP.position.y = jawOffset; }
function updateAccordion(){ const baseBottomWorldY = couchGroup.position.y - (couchBaseHeight/2); const h = Math.max(0.01, baseBottomWorldY - groundY); couchAccordionVisual.scale.y = h / accordionGeometricHeight;
couchAccordionVisual.position.y = h/2; couchAccordion.position.x = couchGroup.position.x; couchAccordion.position.z = couchGroup.position.z; }
function constrainCouch(){
const minY = (couchBaseHeight/2) + groundY;
const maxY = isocenterYTarget + 0.5;
couchGroup.position.y = THREE.MathUtils.clamp(couchGroup.position.y, minY, maxY);
const zExt = couchLength * 0.4;
const xExt = couchWidth * 0.4;
couchTopGroup.position.z = THREE.MathUtils.clamp(couchTopGroup.position.z, -zExt, zExt);
couchTopGroup.position.x = THREE.MathUtils.clamp(couchTopGroup.position.x, -xExt, xExt);
updateAccordion();
}
function enableShadows(o){ o.castShadow = true; o.receiveShadow = true; if (o.children) o.children.forEach(enableShadows); }

// Label math
function updateAllLabelVisibility(){ labeledObjects.forEach(({object,label})=>updateLabelPosition(label, object)); }
function hideAllLabels(){ labeledObjects.forEach(({label})=>{ if(label) label.style.visibility='hidden'; }); }
function updateLabelPosition(labelElement, object3D){ if(!labelElement || !object3D) return; if (!labelsVisible || !object3D.visible){ labelElement.style.visibility='hidden'; return; } const tempV = new THREE.Vector3(); scene.updateMatrixWorld(true);
object3D.getWorldPosition(tempV); tempV.project(camera); const x = (tempV.x * .5 + .5) * renderer.domElement.clientWidth;
const y = (tempV.y * -.5 + .5) * renderer.domElement.clientHeight; const objectWorldPosition = new THREE.Vector3(); object3D.getWorldPosition(objectWorldPosition);
const cameraDirection = new THREE.Vector3(); camera.getWorldDirection(cameraDirection); const objectDirection = new THREE.Vector3().subVectors(objectWorldPosition, camera.position);
if (objectDirection.dot(cameraDirection) > 0 && tempV.z < 1 && tempV.z > -1){ labelElement.style.transform = `translate(-50%, -110%) translate(${x}px,${y}px)`; labelElement.style.visibility = 'visible';
} else { labelElement.style.visibility = 'hidden'; } }

// Window & render loop
function onWindowResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); updateAllLabelVisibility(); }
function animate(){ requestAnimationFrame(animate); controls.update(); if (labelsVisible) updateAllLabelVisibility(); renderer.render(scene, camera); }

// Drag utility for panels
function makeDraggable(element){ let pos1=0,pos2=0,pos3=0,pos4=0; const header=element.querySelector(".ui-header")||element; header.onmousedown=dragMouseDown; function dragMouseDown(e){ e=e||window.event; e.preventDefault(); pos3=e.clientX; pos4=e.clientY; document.onmouseup=closeDragElement; document.onmousemove=elementDrag; } function elementDrag(e){ e=e||window.event; e.preventDefault();
pos1=pos3-e.clientX; pos2=pos4-e.clientY; pos3=e.clientX; pos4=e.clientY; element.style.top=(element.offsetTop - pos2)+"px"; element.style.left=(element.offsetLeft - pos1)+"px"; } function closeDragElement(){ document.onmouseup=null; document.onmousemove=null; } }

// Expose functions to global scope
window.rotateGantry = rotateGantry; window.adjustJaws = adjustJaws; window.moveCouch = moveCouch; window.moveCouchLongitudinal = moveCouchLongitudinal; window.moveCouchLateral = moveCouchLateral; window.toggleDetector = toggleDetector;
window.toggleSideDetector = toggleSideDetector; window.toggleElectronCone = toggleElectronCone; window.toggleLabels = toggleLabels; window.newCase = newCase; window.nudgePatient = nudgePatient; window.centerCouch = centerCouch;
window.checkAlignment = checkAlignment; window.updateIsocenterOffset = updateIsocenterOffset;
window.openTab = (evt, tabName) => {
let i, tabcontent, tablinks;
tabcontent = document.getElementsByClassName("tab-content");
for (i = 0; i < tabcontent.length; i++) { tabcontent[i].style.display = "none"; }
tablinks = document.getElementsByClassName("tab-button");
for (i = 0; i < tablinks.length; i++) { tablinks[i].className = tablinks[i].className.replace(" active", ""); }
document.getElementById(tabName).style.display = "block";
evt.currentTarget.className += " active";
};
</script>
</body>
</html>
