<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>SSD Practice - BEV (CAX Marker on Value)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body { font-family: system-ui, sans-serif; background: #e9ecef; color: #223; margin:0;}
    .container { max-width: 640px; margin: 36px auto 0 auto; background: #fff; border-radius: 13px; box-shadow: 0 2px 18px #0001; padding: 28px 22px 32px 22px;}
    h1 { text-align:center; color: #1976d2; margin-bottom: 16px;}
    .instructions { background: #e3f2fd; border-radius: 10px; padding: 13px 16px; margin-bottom: 18px; color: #135;}
    .problem-settings { margin-bottom: 18px; }
    .problem-settings label { font-weight: 500; }
    .desc { color: #1976d2; font-size: 1.01em; margin: 10px 0 8px 0;}
    .btn { background: #1976d2; color: #fff; border: none; border-radius: 4px; padding: 7px 20px; margin: 8px 6px 0 0; font-size:1.07em; cursor:pointer;}
    .btn.secondary { background: #bcdffb; color: #136;}
    .btn:hover { opacity:0.85; }
    .result, .feedback { margin: 14px 0 0 0; font-size: 1.11em;}
    .pass { color: #18a900; font-weight: bold;}
    .fail { color: #c40000; font-weight: bold;}
    .tick { font-size:1.2em; }
    .solution { background: #e3f2fd; border-radius: 8px; padding: 10px 14px; margin-top: 15px; font-size:0.98em;}
    .section-label { font-weight:bold; color:#1976d2; margin: 8px 0 2px 0; display:block;}
    .summary { background: #d5f5e3; border-radius: 10px; padding: 16px 20px; margin: 20px 0 0 0; color: #1976d2; text-align: center;}
    .badge { display: inline-block; margin: 0 8px; font-size: 1.1em; font-weight: bold; padding: 5px 16px; border-radius: 18px;}
    .badge.gold { background: #ffd700; color: #664d00; border: 2px solid #e5c300;}
    .badge.silver { background: #f2f2f2; color: #444; border: 2px solid #bbb;}
    .badge.bronze { background: #ffe0b3; color: #795548; border: 2px solid #c97;}
    .badge.try { background: #ffbdbd; color:#a00; border:2px solid #f88;}
    .ssd-bev-label { font-size:1.07em; color:#a15c00; font-weight:bold; margin-bottom: 6px;}
    @media (max-width: 700px){ .container{padding: 8px 2vw 18px 2vw;} }
  </style>
</head>
<body>
<div class="container">
  <h1>SSD Practice (BEV, CAX Marker on Value)</h1>
  <div class="instructions" id="instructions">
    <b>Principles:</b>
    <ul>
      <li><b>SAD is always 100 cm.</b></li>
      <li>For isocentric setups: SSD = 100 cm - depth (depth = tumor distance from skin).</li>
      <li>For non-isocentric setups: field is set with SSD = 100 cm at the skin surface.</li>
      <li>In BEV problems, the entire canvas is the skin surface. The field is shown as a rectangle centered on the canvas. The <b>CAX marker</b> (<span style="color:#c60000;">circle or bold +</span>) is exactly on the SSD value, with the CAX label to the side. The vertical SSD scale always runs through the CAX. Read the SSD value at the marker.</li>
      <li>All answers must be rounded to the nearest tenth (e.g., 97.4).</li>
      <li>Choose your practice quantity. Get a summary and badge at the end!</li>
    </ul>
  </div>
  <div class="problem-settings" id="problem-settings">
    <label for="num-problems">Number of Problems:</label>
    <input type="number" id="num-problems" min="3" max="20" value="6" style="width:48px;">
    <button class="btn secondary" onclick="startSSDPractice();return false;">Start Practice</button>
  </div>
  <div id="ssd-practice-area" style="display:none;">
    <div style="margin-bottom: 5px; color:#1976d2; font-weight:bold;" id="ssd-prob-status"></div>
    <div id="ssd-prob-type" style="font-weight:bold; margin-bottom:7px; color:#007096;"></div>
    <div class="desc" id="ssd-desc"></div>
    <div id="ssd-bev-area" style="display:none;">
      <div class="ssd-bev-label">BEV: Read the SSD value at the <span style="color:#c60000;">CAX marker</span> (center of the field/canvas) from the vertical scale.</div>
      <canvas id="ssd-bev-canvas" width="500" height="440"></canvas>
    </div>
    <form class="inputs" id="ssd-inputs-form" autocomplete="off" onsubmit="event.preventDefault();">
      <span id="ssd-entry-label"></span>
      <input type="number" step="0.1" id="ssd-entry" style="width:80px;">
    </form>
    <button class="btn" onclick="checkSSDProb()">Check</button>
    <button class="btn secondary" onclick="showSSDSolution()">Show Solution</button>
    <button class="btn secondary" onclick="nextSSDProb();return false;" id="ssd-next-btn" style="display:none;">Next Problem</button>
    <div class="result" id="ssd-feedback"></div>
    <div class="solution" id="ssd-solution" style="display:none;"></div>
  </div>
  <div id="ssd-completion-summary" class="summary" style="display:none;"></div>
</div>
<script>
// Toggle between "circle" or "plus" for the CAX marker style
const caxStyle = "plus"; // or "circle"
let ssdTotal = 6;
let ssdCurrent = 0;
let ssdResults = [];
let ssdProblems = [];

function startSSDPractice() {
  ssdTotal = Math.max(3, Math.min(20, Math.round(+document.getElementById('num-problems').value || 6)));
  ssdCurrent = 0;
  ssdResults = [];
  ssdProblems = [];
  document.getElementById('ssd-practice-area').style.display = '';
  document.getElementById('problem-settings').style.display = 'none';
  document.getElementById('ssd-completion-summary').style.display = 'none';
  for (let i=0;i<ssdTotal;++i) {
    let t = Math.random() < 0.5 ? 0 : 1; // 0 for BEV, 1 for calculation
    if (i<2 && i < ssdProblems.length) t = i; // Ensure first two types are covered if total is small
    else if (i<2) t = i % 2; // if ssdProblems is empty
    ssdProblems.push(t);
  }
  ssdProblems.sort(() => Math.random() - 0.5); // Shuffle problem types
  randomizeSSDProb();
  updateSSDStatus();
}

function updateSSDStatus() {
  document.getElementById('ssd-prob-status').textContent = `Problem ${ssdCurrent+1} of ${ssdTotal}`;
}

let ssdProbParams = {};

function randomizeSSDProb() {
  document.getElementById('ssd-feedback').textContent = '';
  document.getElementById('ssd-solution').style.display = 'none';
  document.getElementById('ssd-next-btn').style.display = 'none';
  document.getElementById('ssd-bev-area').style.display = 'none';
  document.getElementById('ssd-inputs-form').reset();

  let type = ssdProblems[ssdCurrent];
  ssdProbParams = { type };

  if (type === 0) {
    // BEV SSD visual read (vertical SSD scale, CAX at field/canvas center)
    document.getElementById('ssd-prob-type').textContent = "Type: BEV SSD (CAX Marker on Value)";
    document.getElementById('ssd-desc').textContent = "Read the SSD at the CAX marker (red) from the vertical scale. The value is not labeled—you must estimate visually.";
    document.getElementById('ssd-bev-area').style.display = '';
    document.getElementById('ssd-entry-label').textContent = "SSD at CAX (cm):";

    // Generate random field dimensions first
    ssdProbParams.x1 = +(5 + Math.random() * 10).toFixed(1);
    ssdProbParams.x2 = +(5 + Math.random() * 10).toFixed(1);
    ssdProbParams.y1 = +(5 + Math.random() * 10).toFixed(1);
    ssdProbParams.y2 = +(5 + Math.random() * 10).toFixed(1);

    // --- MODIFIED LOGIC TO CONSTRAIN SSD TO BE WITHIN THE FIELD ---
    let c = document.getElementById('ssd-bev-canvas');
    let canvas_cx = c.width / 2;
    let canvas_cy = c.height / 2;

    let fieldPxPerCmVisual = 12; // Visual scaling for field size on canvas
    let fieldH_px = (ssdProbParams.y1 + ssdProbParams.y2) * fieldPxPerCmVisual;
    let fieldTop_px = canvas_cy - fieldH_px / 2;    // Field is centered on canvas_cy
    let fieldBot_px = canvas_cy + fieldH_px / 2;

    // SSD scale parameters (must match those in drawSSDBEV)
    let scale_ssdMin_val = 80, scale_ssdMax_val = 110;
    let scale_top_canvas_px = 60; // Y pixel for top of scale line on canvas
    let scale_bottom_canvas_px = c.height - 40; // Y pixel for bottom of scale line
    let scale_pxPerCm = (scale_bottom_canvas_px - scale_top_canvas_px) / (scale_ssdMax_val - scale_ssdMin_val);

    if (scale_pxPerCm === 0) { // Avoid division by zero if scale has no range
        console.error("SSD scale has zero range (pxPerCm is zero). Defaulting SSD.");
        ssdProbParams.ssd = scale_ssdMin_val; // Or some other sensible default
    } else {
        // Convert the field's actual top/bottom pixel boundaries to SSD values
        let ssd_at_fieldTop = scale_ssdMin_val + (fieldTop_px - scale_top_canvas_px) / scale_pxPerCm;
        let ssd_at_fieldBot = scale_ssdMin_val + (fieldBot_px - scale_top_canvas_px) / scale_pxPerCm;

        let constrained_ssd_min_gen = Math.max(scale_ssdMin_val, ssd_at_fieldTop);
        let constrained_ssd_max_gen = Math.min(scale_ssdMax_val, ssd_at_fieldBot);
        
        let randomSSDInConstrainedRange;
        if (constrained_ssd_min_gen > constrained_ssd_max_gen) {
            // This means the field (e.g. very small field) does not overlap the valid SSD range [80,110]
            // Or it's smaller than one pixel on the scale can resolve.
            // Fallback: use the SSD value at the vertical center of the field, clamped.
            let field_center_ssd_val = scale_ssdMin_val + (canvas_cy - scale_top_canvas_px) / scale_pxPerCm;
            randomSSDInConstrainedRange = Math.max(scale_ssdMin_val, Math.min(scale_ssdMax_val, field_center_ssd_val));
            console.warn("CAX constrained SSD range was invalid or too small. Defaulting to field's vertical center SSD:", randomSSDInConstrainedRange);
        } else {
            randomSSDInConstrainedRange = constrained_ssd_min_gen + Math.random() * (constrained_ssd_max_gen - constrained_ssd_min_gen);
        }
        ssdProbParams.ssd = randomSSDInConstrainedRange;
    }
    
    ssdProbParams.ssd = +(Math.round(ssdProbParams.ssd * 10) / 10).toFixed(1);
    // --- END OF MODIFIED LOGIC ---

    drawSSDBEV(); // Draw with the new constrained SSD

  } else { // type === 1 (Calculation problems)
    let scenario = Math.random();
    let depth = +(Math.round((3+Math.random()*17)*10)/10).toFixed(1); // Ensure depth is string for display then number for calc
    depth = parseFloat(depth);

    if (scenario < 0.5) { // Isocentric
      ssdProbParams.scenario = "iso";
      ssdProbParams.SAD = 100;
      ssdProbParams.depth = depth;
      ssdProbParams.answer = +(100 - depth).toFixed(1); // Ensure correct rounding after calculation
      document.getElementById('ssd-prob-type').textContent = "Type: Isocentric Calculation";
      document.getElementById('ssd-desc').textContent = `A patient is treated isocentrically (SAD = 100 cm). Tumor depth: ${depth.toFixed(1)} cm. What is the SSD at the skin?`;
      document.getElementById('ssd-entry-label').textContent = "Calculated SSD (cm):";
    } else { // Non-isocentric
      ssdProbParams.scenario = "noniso";
      ssdProbParams.answer = 100.0; // Answer should be number for comparison
      document.getElementById('ssd-prob-type').textContent = "Type: Non-Isocentric (SSD Setup)";
      document.getElementById('ssd-desc').textContent = `A patient is treated with an SSD setup (non-isocentric). What is the SSD at the skin surface?`;
      document.getElementById('ssd-entry-label').textContent = "SSD (cm):";
    }
  }
}

function drawSSDBEV() {
  let c = document.getElementById('ssd-bev-canvas');
  let ctx = c.getContext('2d');
  ctx.clearRect(0,0,c.width,c.height);
  // Layout: vertical scale (center), field, CAX at field/canvas center
  let cx = c.width/2, cy = c.height/2;
  let fieldPxPerCm = 12; // Visual representation scale for field size
  let fieldW = (ssdProbParams.x1 + ssdProbParams.x2) * fieldPxPerCm;
  let fieldH = (ssdProbParams.y1 + ssdProbParams.y2) * fieldPxPerCm;
  let fieldLeft = cx - fieldW/2;
  let fieldTop = cy - fieldH/2;
  let fieldRight = cx + fieldW/2;
  let fieldBot = cy + fieldH/2;

  // Draw field jaws
  ctx.save();
  ctx.strokeStyle="#1976d2";
  ctx.lineWidth=2.6;
  ctx.setLineDash([14,7]);
  ctx.strokeRect(fieldLeft, fieldTop, fieldW, fieldH); // Use fieldW, fieldH
  ctx.restore();

  // Draw vertical SSD scale through center
  let ssdMin = 80, ssdMax = 110; // Scale range values
  let scaleTopY = 60, scaleBottomY = c.height-40; // Pixel Y for top/bottom of scale line on canvas
  let pxPerCmOnScale = (scaleBottomY-scaleTopY)/(ssdMax-ssdMin);

  if (pxPerCmOnScale <= 0) { // Prevent issues if scale params are bad
      console.error("Invalid SSD scale parameters, pxPerCmOnScale is not positive.");
      return;
  }

  ctx.save();
  ctx.strokeStyle="#1976d2";
  ctx.lineWidth=2.2;
  ctx.beginPath();
  ctx.moveTo(cx, scaleTopY-22); // Extend scale line a bit
  ctx.lineTo(cx, scaleBottomY+22);
  ctx.stroke();
  ctx.restore();

  for (let i = ssdMin; i <= ssdMax; i += 1) {
    let y = scaleTopY + (i-ssdMin)*pxPerCmOnScale;
    ctx.beginPath();
    ctx.strokeStyle = i%5==0 ? "#1976d2" : "#888";
    ctx.lineWidth = i%5==0 ? 2.2 : 1;
    ctx.moveTo(cx-18, y); ctx.lineTo(cx+18, y);
    ctx.stroke();
    if (i%5===0) {
      ctx.font = "10.5px monospace";
      ctx.fillStyle = "#1976d2";
      ctx.fillText(i, cx+22, y+3);
      ctx.fillText(i, cx-40, y+3); // Adjusted for potentially wider numbers
    }
  }

  // CAX marker at center horizontally, and at the true SSD value vertically
  let markerY = scaleTopY + (ssdProbParams.ssd - ssdMin) * pxPerCmOnScale;

  if (caxStyle === "circle") {
    ctx.beginPath();
    ctx.arc(cx, markerY, 12, 0, 2*Math.PI);
    ctx.fillStyle = "#fff"; // White fill for better visibility of plus/circle
    ctx.fill();
    ctx.strokeStyle="#c60000"; // Red CAX
    ctx.lineWidth=3.0;
    ctx.stroke();
  } else if (caxStyle === "plus") {
    ctx.save();
    ctx.strokeStyle="#c60000"; // Red CAX
    ctx.lineWidth=5.5; // Bold plus
    ctx.beginPath();
    ctx.moveTo(cx-10, markerY); ctx.lineTo(cx+10, markerY);
    ctx.moveTo(cx, markerY-10); ctx.lineTo(cx, markerY+10);
    ctx.stroke();
    ctx.restore();
  }
  // CAX label offset to right of marker
  ctx.font = "bold 15px sans-serif";
  ctx.fillStyle="#c60000";
  ctx.textAlign = "left"; // Align text to start to the right of cx+16
  ctx.fillText("CAX", cx+16, markerY+6); // Position relative to marker

  // Jaw labels (ensure they don't overlap with scale numbers if field is too wide/narrow)
  ctx.font = "bold 13px system-ui, sans-serif";
  ctx.fillStyle="#1976d2";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("Y1", cx, fieldTop-12); // Adjusted offset
  ctx.fillText("Y2", cx, fieldBot+12); // Adjusted offset

  ctx.textAlign = "right";
  ctx.fillText("X1", fieldLeft-8, cy);
  ctx.textAlign = "left";
  ctx.fillText("X2", fieldRight+8, cy);
}

function checkSSDProb() {
  let userInput = document.getElementById('ssd-entry').value;
  if (userInput === "") {
      document.getElementById('ssd-feedback').innerHTML = '<span class="fail">Please enter a value.</span>';
      return;
  }
  let userVal = parseFloat(userInput);
  userVal = +(Math.round(userVal*10)/10).toFixed(1); // Round user input like answers

  let type = ssdProbParams.type;
  let correct = false;
  let answer = null;
  let tol = 0.2; // Tolerance for BEV reading
  
  if (type === 0) { // BEV
    answer = parseFloat(ssdProbParams.ssd);
    correct = Math.abs(userVal-answer)<=tol;
  } else { // Calculation
    answer = parseFloat(ssdProbParams.answer);
    correct = Math.abs(userVal-answer)<=0.05; // Tighter tolerance for calculations
  }

  let fb = correct
    ? `<span class="pass">&#10003; Correct!</span>`
    : `<span class="fail">&#10008; Incorrect.</span> Correct value was: <b>${answer.toFixed(1)} cm</b>`;
  ssdResults[ssdCurrent] = { correct, user: userVal, actual: answer, feedbackText: fb }; // Store more info
  document.getElementById('ssd-feedback').innerHTML = fb;
  document.getElementById('ssd-next-btn').style.display = '';
  if (ssdCurrent === ssdTotal-1) {
    document.getElementById('ssd-next-btn').textContent = "Finish & View Summary";
  } else {
    document.getElementById('ssd-next-btn').textContent = "Next Problem";
  }
}

function showSSDSolution() {
  let type = ssdProbParams.type;
  let sol = '';
  if (type === 0) { // BEV
    sol = `The CAX marker (red) is positioned on the vertical scale at <b>${ssdProbParams.ssd.toFixed(1)} cm</b>. You need to read this value from the scale markings.`;
  } else if (ssdProbParams.scenario==="iso") {
    sol = `For an isocentric setup (SAD = 100 cm): <br>SSD = SAD – depth <br>SSD = 100 cm – ${ssdProbParams.depth.toFixed(1)} cm = <b>${ssdProbParams.answer.toFixed(1)} cm</b>`;
  } else if (ssdProbParams.scenario==="noniso") {
    sol = `For a non-isocentric (SSD) setup, the SSD is set directly on the skin surface, typically to <b>100.0 cm</b> by convention unless otherwise specified.`;
  }
  document.getElementById('ssd-solution').style.display = '';
  document.getElementById('ssd-solution').innerHTML = sol;
}

function nextSSDProb() {
  if (ssdCurrent < ssdTotal-1) {
    ssdCurrent++;
    randomizeSSDProb();
    updateSSDStatus();
  } else {
    finishSSDPractice();
  }
}

function finishSSDPractice() {
  document.getElementById('ssd-practice-area').style.display = 'none';
  let nCorrect = ssdResults.filter(r => r && r.correct).length;
  let percent = Math.round((nCorrect/ssdTotal)*100);
  let badge = "";
  let badgeText = "";

  if (percent === 100)      { badge = "gold"; badgeText = "Perfect Score!"; }
  else if (percent >= 90)   { badge = "gold"; badgeText = "Excellent!"; }
  else if (percent >= 75)   { badge = "silver"; badgeText = "Great Job!"; }
  else if (percent >= 60)   { badge = "bronze"; badgeText = "Good Effort!"; }
  else                      { badge = "try"; badgeText = "Keep Practicing!"; }

  let summaryHTML = `<div style="font-size:1.2em;">Practice Complete!</div>
  <div style="margin:10px 0 18px 0;">You answered <b>${nCorrect} of ${ssdTotal}</b> correctly (${percent}%).</div>
  <span class="badge ${badge}">${badgeText}</span>
  <div style="margin:18px 0 0 0; font-size:1em;">Review:</div>
  <ol style="text-align:left; margin: 8px auto 0 auto; padding-left: 2.5em; max-width: 80%; color:#333; list-style-type: decimal;">`;
  
  ssdResults.forEach((r, i) => {
    if (r) { // Check if result object exists
        summaryHTML += `<li>Problem ${i+1}: ${r.correct ? '<span class="pass tick">&#10003;</span> Correct.' : '<span class="fail tick">&#10008;</span> Incorrect.'} Your answer: ${r.user.toFixed(1)}, Correct: ${r.actual.toFixed(1)}</li>`;
    } else {
        summaryHTML += `<li>Problem ${i+1}: Not attempted.</li>`;
    }
  });
  summaryHTML += `</ol>
  <button class="btn" onclick="restartSSDPractice();" style="margin-top:20px;">Practice Again</button>
  `;
  document.getElementById('ssd-completion-summary').innerHTML = summaryHTML;
  document.getElementById('ssd-completion-summary').style.display = '';
}

function restartSSDPractice() {
  document.getElementById('ssd-practice-area').style.display = 'none';
  document.getElementById('problem-settings').style.display = '';
  document.getElementById('ssd-completion-summary').style.display = 'none';
  document.getElementById('ssd-feedback').textContent = '';
  document.getElementById('ssd-solution').style.display = 'none';
  // Reset problem number input to its default or last value if desired
  // document.getElementById('num-problems').value = "6"; 
}

// Initial call if needed, or wait for user to click "Start Practice"
// randomizeSSDProb(); 
// updateSSDStatus();

</script>
</body>
</html>
