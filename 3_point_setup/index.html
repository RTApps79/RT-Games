<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>LINAC + Patient Alignment Simulator (Head-First Supine)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin: 0; overflow: hidden; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
    canvas { display: block; }

    /* Main LINAC console */
    #console-window {
      position: absolute; top: 20px; right: 20px; width: 320px; background: #f7f7f7;
      border: 1px solid #ccc; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.18);
      z-index: 100; display: flex; flex-direction: column; backdrop-filter: blur(2px);
    }
    #console-header { padding: 10px; background: #ececec; font-weight: 700; cursor: move;
      border-top-left-radius: 10px; border-top-right-radius: 10px; border-bottom: 1px solid #dcdcdc; text-align: center; }
    #console-content { padding: 12px; max-height: 80vh; overflow-y: auto; }
    #console-content button { display: block; width: 100%; margin: 6px 0; padding: 8px 12px; font-size: 14px; cursor: pointer; }
    #console-content strong { display: block; margin-top: 10px; margin-bottom: 6px; }

    /* Alignment panel */
    #align-window {
      position: absolute; top: 20px; left: 20px; width: 340px; background: #f7f7f7;
      border: 1px solid #ccc; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.18);
      z-index: 100; display: flex; flex-direction: column; backdrop-filter: blur(2px);
    }
    #align-header { padding: 10px; background: #ececec; font-weight: 700; cursor: move;
      border-top-left-radius: 10px; border-top-right-radius: 10px; border-bottom: 1px solid #dcdcdc; text-align: center; }
    #align-content { padding: 12px; }
    #align-content .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 6px; }
    #align-content .row3 { display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; margin-bottom: 6px; }
    #align-content button { width: 100%; padding: 8px 12px; font-size: 13px; cursor: pointer; }
    #alignmentMessage { font-weight: 600; min-height: 2.2em; margin-top: 8px; }

    /* Floating labels for parts */
    .component-label { position: absolute; background: rgba(0,0,0,0.7); color: #fff; padding: 3px 7px; border-radius: 4px;
      font-size: 12px; pointer-events: none; transform: translate(-50%, -110%); white-space: nowrap; z-index: 5; visibility: hidden; }
    #label-axisX { color: #FF7777; }
    #label-axisY { color: #77FF77; }
    #label-axisZ { color: #7777FF; }

    /* Legend pill */
    #legend {
      position: absolute; bottom: 16px; left: 50%; transform: translateX(-50%);
      background: rgba(255,255,255,0.9); border: 1px solid #ddd; border-radius: 999px; padding: 6px 12px; font-size: 13px;
      box-shadow: 0 4px 10px rgba(0,0,0,0.12); z-index: 50;
    }
    .dot { display: inline-block; width: 10px; height: 10px; border-radius: 50%; margin-right: 6px; vertical-align: middle; }
  </style>

  <script type="importmap">
    {
      "imports": {
        "three": "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js",
        "three/examples/jsm/controls/OrbitControls.js": "https://cdn.jsdelivr.net/npm/three@0.160.1/examples/jsm/controls/OrbitControls.js"
      }
    }
  </script>
</head>
<body>
  <!-- LINAC Console -->
  <div id="console-window">
    <div id="console-header">LINAC Console</div>
    <div id="console-content">
      <strong>Gantry</strong>
      <button onclick="rotateGantry(true)">Rotate Gantry ← CCW</button>
      <button onclick="rotateGantry(false)">Rotate Gantry → CW</button>
      <hr>
      <strong>Collimator</strong>
      <button onclick="adjustJaws(true)">Open Jaws</button>
      <button onclick="adjustJaws(false)">Close Jaws</button>
      <hr>
      <strong>Couch</strong>
      <button onclick="moveCouch(true)">Move Couch ↑ (Vertical Up)</button>
      <button onclick="moveCouch(false)">Move Couch ↓ (Vertical Down)</button>
      <button onclick="moveCouchLongitudinal(true)">Move Couch In (Toward Gantry)</button>
      <button onclick="moveCouchLongitudinal(false)">Move Couch Out (Away)</button>
      <button onclick="moveCouchLateral(false)">Move Couch Right (−X)</button>
      <button onclick="moveCouchLateral(true)">Move Couch Left (+X)</button>
      <hr>
      <strong>Imaging</strong>
      <button id="detectorToggleButton" onclick="toggleDetector()">Extend kV Detector (AP)</button>
      <button id="sideDetectorToggleButton" onclick="toggleSideDetector()">Extend Side Imagers (Lat)</button>
      <hr>
      <strong>Accessories</strong>
      <button id="coneToggleButton" onclick="toggleElectronCone()">Attach Electron Cone</button>
      <hr>
      <button onclick="toggleLabels()">Toggle Labels</button>
    </div>
  </div>

  <!-- Alignment Console -->
  <div id="align-window">
    <div id="align-header">Tattoo-to-Laser Alignment</div>
    <div id="align-content">
      <div style="font-size:12px; opacity:.9; margin-bottom:6px;">Goal: align the tumor (and patient tattoos) to the room lasers at isocenter.</div>
      <div class="row3">
        <button onclick="nudgePatient(-1,0,0)">X− Lateral</button>
        <button onclick="nudgePatient(0,1,0)">Y+ Up</button>
        <button onclick="nudgePatient(1,0,0)">X+ Lateral</button>
      </div>
      <div class="row3">
        <button onclick="nudgePatient(0,0,-1)">Z− In</button>
        <button onclick="checkAlignment()">Check Alignment</button>
        <button onclick="nudgePatient(0,0,1)">Z+ Out</button>
      </div>
      <div class="row">
        <button onclick="newCase()">New Random Case</button>
        <button onclick="centerCouch()"><span>Auto‑Center Couch</span></button>
      </div>
      <div id="alignmentMessage">Use the couch and nudge controls to bring tattoos onto the laser lines.</div>
    </div>
  </div>

  <!-- On-screen labels (toggleable) -->
  <div id="label-drivestand" class="component-label">Drivestand</div>
  <div id="label-acceleratorHousing" class="component-label">Accelerator Housing</div>
  <div id="label-verticalArmL" class="component-label">Vertical Arm</div>
  <div id="label-head" class="component-label">Head</div>
  <div id="label-couchBase" class="component-label">Couch Base</div>
  <div id="label-couchTop" class="component-label">Couch Top</div>
  <div id="label-couchAccordion" class="component-label">Accordion</div>
  <div id="label-detectorPanel" class="component-label">Detector Panel</div>
  <div id="label-sideDetectorPanel" class="component-label">Side Detector Panel</div>
  <div id="label-kvTube" class="component-label">kV X-Ray Tube</div>
  <div id="label-electronCone" class="component-label">Electron Cone</div>
  <div id="label-handPendant" class="component-label">Hand Pendant</div>
  <div id="label-axisX" class="component-label">X</div>
  <div id="label-axisY" class="component-label">Y</div>
  <div id="label-axisZ" class="component-label">Z</div>
  <div id="label-electronGun" class="component-label">Electron Gun</div>
  <div id="label-waveguide" class="component-label">Waveguide (Acc.)</div>
  <div id="label-target" class="component-label">Target</div>
  <div id="label-klystron" class="component-label">Klystron</div>
  <div id="label-klystronWaveguide" class="component-label">Waveguide (Klystron)</div>

  <!-- Small legend -->
  <div id="legend">
    <span class="dot" style="background:#ff0000"></span>Room Lasers (Red)
    &nbsp;&nbsp; <span class="dot" style="background:#00ff00"></span>Tattoos (Green)
    &nbsp;&nbsp; <span class="dot" style="background:#8B0000"></span>Tumor (Maroon)
  </div>

  <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/examples/jsm/controls/OrbitControls.js';

    // ===== Core Scene =====
    let camera, scene, renderer, controls;

    // LINAC & Couch
    let drivestand, acceleratorHousing, verticalArmL, head;
    let couchGroup, couchSupportBase, couchAccordion, couchAccordionVisual, couchTopGroup, couchPlatform;

    // Imaging
    let detectorPanel, detectorArm, detectorExtended = false;
    let sideDetectorPanel, sideDetectorArm, sideDetectorShortArm, sideDetectorExtended = false;
    let kvTubeGroup, kvTubeHousing, kvTubeHead, kvTubeShortArm, kvTubeLongArm;

    // Beam shaping & accessories
    let jawXN_new, jawXP_new, jawZN_new, jawZP_new, headSize = 0.6, jawOffset = 0.1;
    let electronCone, isConeAttached = false;

    // Power & RF
    let electronGun, waveguide, target, klystron, wgStaticVert, wgStaticHoriz, wgRotatingVert, wgRotatingHoriz;

    // Patient model & alignment
    let patientModel, tumor, tattooAnterior, tattooLeft, tattooRight;
    const patientMat = new THREE.MeshStandardMaterial({ color: 0xAD8C74, transparent: false, opacity: 1 });
    const tattooMat = new THREE.MeshBasicMaterial({ color: 0x00ff00, depthTest: false });
    const tumorMat  = new THREE.MeshStandardMaterial({ color: 0x8B0000, depthTest: false, transparent: true, opacity: 0.85 });

    // UI
    const alignmentMessageElement = document.getElementById('alignmentMessage');

    // Labels
    const labels = {};
    const labeledObjects = [];
    let labelsVisible = false;

    // Geometry/layout constants
    const isocenterYTarget = 1.5;            // Gantry pivot height
    // REVISION: New constant to control the vertical laser/isocenter offset from the head's center
    const isocenterVerticalOffset = 1.1;     // Adjust this to move the true isocenter down
    const gantryPlaneZTarget = -1.0;         // Gantry rotation plane (Z)
    const couchSeparationOffset = 0.5;       // Couch base separation from gantry plane (Z)
    const couchWidth = 0.8;
    const couchPlatformHeight = 0.15;
    const couchLength = 2.2; 
    const couchBaseHeight = 0.7;
    const groundY = -0.05;
    const newVerticalArmTotalLength = 2.0;   // Gantry arm length
    const verticalArmLSize = 0.4;
    const acceleratorHousingLength = 2.5;
    const detectorPanelWidth = 0.7, detectorPanelHeight = 0.6, detectorPanelThickness = 0.05, detectorArmRadius = 0.03;
    const sideDetectorOffsetX = 0.3;
    const accordionGeometricHeight = 1.0;

    // Alignment state
    const MOVE_STEP = 0.001;                  // small nudges for fine alignment (meters)
    const ALIGNMENT_TOLERANCE = 0.01;        // within 1 cm considered aligned
    let tumorLocalOffset = new THREE.Vector3();   // tumor offset in patient local coords

    // Isocenter vector
    let ISO; // Will be calculated dynamically based on the head's position.

    // Materials
    const lightGrayMat = new THREE.MeshStandardMaterial({ color: 0xd3d3d3 });
    const lightBlueMat = new THREE.MeshStandardMaterial({ color: 0xadd8e6, transparent: true, opacity: 0.5 });
    const brightOrangeMat = new THREE.MeshStandardMaterial({ color: 0xffa500 });
    const brightCyanMat = new THREE.MeshStandardMaterial({ color: 0x00ffff });
    const transparentLightGrayMat = new THREE.MeshStandardMaterial({ color: 0xc0c0c0, transparent: true, opacity: 0.55 });
    const lightBeigeMat = new THREE.MeshStandardMaterial({ color: 0xf5f5dc });
    const mediumGrayMat = new THREE.MeshStandardMaterial({ color: 0x909090 });
    const darkGrayMatMaterial = new THREE.MeshStandardMaterial({ color: 0x505050 });
    const metallicGrayMat = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.5, roughness: 0.5 });
    const targetMat = new THREE.MeshStandardMaterial({ color: 0x666666, metalness: 0.8, roughness: 0.3 });
    const klystronMat = new THREE.MeshStandardMaterial({ color: 0x778899, metalness: 0.3, roughness: 0.6 });
    const klystronWaveguideMat = new THREE.MeshStandardMaterial({ color: 0xb8860b, metalness: 0.7, roughness: 0.4 });

    // ===== Init =====
    init();
    animate();

    function init() {
      // Scene
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0xf0f0f0);

      // Camera
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 120);
      
      // Renderer
      renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;
      document.body.appendChild(renderer.domElement);

      // Controls
      controls = new OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true; controls.dampingFactor = 0.08;
      
      // Lights
      scene.add(new THREE.AmbientLight(0x808080));
      const dir = new THREE.DirectionalLight(0xffffff, 0.7);
      dir.position.set(15, 20, 15);
      dir.castShadow = true; dir.shadow.mapSize.set(2048,2048); scene.add(dir);

      // Ground
      const textureLoader = new THREE.TextureLoader();
      const floorTexture = textureLoader.load('https://threejs.org/examples/textures/floors/FloorsCheckerboard_S_Diffuse.jpg', () => {
          renderer.render(scene, camera); // Render once texture is loaded
      });
      floorTexture.wrapS = THREE.RepeatWrapping;
      floorTexture.wrapT = THREE.RepeatWrapping;
      floorTexture.repeat.set(40, 40);
      const groundPlane = new THREE.Mesh(
        new THREE.PlaneGeometry(40, 40),
        new THREE.MeshStandardMaterial({ map: floorTexture, side: THREE.DoubleSide })
      );
      groundPlane.rotation.x = -Math.PI / 2;
      groundPlane.position.y = groundY;
      groundPlane.receiveShadow = true;
      scene.add(groundPlane);


      // Axes (thin lines)
      const axisLen = 3; const origin = new THREE.Vector3();
      scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([origin, new THREE.Vector3(axisLen,0,0)]), new THREE.LineBasicMaterial({ color: 0xff0000 })));
      scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([origin, new THREE.Vector3(0,axisLen,0)]), new THREE.LineBasicMaterial({ color: 0x00ff00 })));
      scene.add(new THREE.Line(new THREE.BufferGeometry().setFromPoints([origin, new THREE.Vector3(0,0,axisLen)]), new THREE.LineBasicMaterial({ color: 0x0000ff })));

      // Gantry assembly
      ganryAdd(scene);

      // Couch
      buildCouch();

      // Patient (head-first supine on couch top)
      buildPatient();

      // Room lasers at ISO (crosshair)
      buildLasers();

      // Set camera and controls target after ISO is calculated
      camera.position.set(8, isocenterYTarget + 3, ISO.z + 9);
      camera.lookAt(0, isocenterYTarget, ISO.z);
      controls.target.set(0, isocenterYTarget, ISO.z);
      controls.update();

      // Labels hookup
      hookLabels();

      // UI
      makeDraggable(document.getElementById('console-window'));
      makeDraggable(document.getElementById('align-window'));

      // Window events
      window.addEventListener('resize', onWindowResize);

      // First case
      newCase();
    }

    // ---- Build Gantry/LINAC ----
    function ganryAdd(root) {
      const gantrySetupGroup = new THREE.Group();
      gantrySetupGroup.position.set(0, 0, gantryPlaneZTarget);
      root.add(gantrySetupGroup);

      const drivestandHeight = isocenterYTarget + 0.8;
      const drivestandDepth = 0.8;
      const drivestandMaterial = new THREE.MeshStandardMaterial({ color: 0xeee8aa, transparent: true, opacity: 0.35, depthWrite: false });
      drivestand = new THREE.Mesh(new THREE.BoxGeometry(0.8, drivestandHeight, drivestandDepth), drivestandMaterial);
      
      drivestand.position.set(0, groundY + (drivestandHeight / 2), -drivestandDepth / 2);
      gantrySetupGroup.add(drivestand);
      enableShadows(drivestand);

      const gantryRotatingAssembly = new THREE.Group();
      gantryRotatingAssembly.position.set(0, isocenterYTarget, 0); 
      gantrySetupGroup.add(gantryRotatingAssembly);
      enableShadows(gantryRotatingAssembly);
      window.gantryRotatingAssembly = gantryRotatingAssembly;

      const acceleratorHousingHeight = 0.5;
      const horizontalArmY = (newVerticalArmTotalLength / 2) + (acceleratorHousingHeight / 2);

      // Arms & head
      verticalArmL = new THREE.Mesh(new THREE.BoxGeometry(verticalArmLSize, newVerticalArmTotalLength, verticalArmLSize), lightBlueMat);
      gantryRotatingAssembly.add(verticalArmL); 

      acceleratorHousing = new THREE.Mesh(new THREE.BoxGeometry(acceleratorHousingHeight, acceleratorHousingHeight, acceleratorHousingLength), lightBlueMat);
      acceleratorHousing.position.set(0, horizontalArmY, acceleratorHousingLength / 2);
      gantryRotatingAssembly.add(acceleratorHousing);

      head = new THREE.Mesh(new THREE.BoxGeometry(headSize, headSize, headSize), transparentLightGrayMat);
      head.position.set(0, horizontalArmY, acceleratorHousingLength);
      gantryRotatingAssembly.add(head);

      // Calculate the final world position of the head and set it as the global ISO
      head.updateWorldMatrix(true, false);
      ISO = head.getWorldPosition(new THREE.Vector3());
      // REVISION: Apply the vertical offset to the calculated isocenter
      ISO.y -= isocenterVerticalOffset;

      // Beamline internals
      const gunLength = 0.3, gunRadius = 0.15;
      electronGun = new THREE.Mesh(new THREE.CylinderGeometry(gunRadius, gunRadius * 0.8, gunLength, 16), metallicGrayMat);
      electronGun.rotation.x = Math.PI / 2;
      electronGun.position.set(0, 0, -acceleratorHousingLength / 2 - gunLength / 2);
      acceleratorHousing.add(electronGun);
      enableShadows(electronGun);

      const waveguideRadius = 0.05;
      const waveguideLength = acceleratorHousingLength - gunLength - 0.1;
      waveguide = new THREE.Mesh(new THREE.CylinderGeometry(waveguideRadius, waveguideRadius, waveguideLength, 16), metallicGrayMat);
      waveguide.rotation.x = Math.PI / 2;
      waveguide.position.set(0, 0, electronGun.position.z + gunLength / 2 + waveguideLength / 2);
      acceleratorHousing.add(waveguide);
      enableShadows(waveguide);

      const targetRadius = 0.08, targetThickness = 0.02;
      target = new THREE.Mesh(new THREE.CylinderGeometry(targetRadius, targetRadius, targetThickness, 16), targetMat);
      target.rotation.x = Math.PI / 2;
      target.position.set(0, 0, -0.1);
      head.add(target);
      enableShadows(target);

      // Jaws
      const jawsGroup = new THREE.Group();
      head.add(jawsGroup);
      const jawThickness = 0.06;
      const jawDepth = 0.3;
      const jawPairSpan = headSize * 0.8;
      jawXN_new = new THREE.Mesh(new THREE.BoxGeometry(jawThickness, jawDepth, jawPairSpan), brightOrangeMat);
      jawXP_new = new THREE.Mesh(new THREE.BoxGeometry(jawThickness, jawDepth, jawPairSpan), brightOrangeMat);
      jawZN_new = new THREE.Mesh(new THREE.BoxGeometry(jawPairSpan, jawDepth, jawThickness), brightCyanMat);
      jawZP_new = new THREE.Mesh(new THREE.BoxGeometry(jawPairSpan, jawDepth, jawThickness), brightCyanMat);
      jawsGroup.add(jawXN_new, jawXP_new, jawZN_new, jawZP_new);
      setJawOffset(jawOffset);

      // Detector (AP)
      detectorArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), lightGrayMat);
      detectorPanel = new THREE.Mesh(new THREE.BoxGeometry(detectorPanelWidth, detectorPanelHeight, detectorPanelThickness), lightGrayMat);
      gantryRotatingAssembly.add(detectorArm, detectorPanel);
      setDetectorState(false);

      // Side imagers (Lat) & kV tube
      sideDetectorPanel = new THREE.Mesh(new THREE.BoxGeometry(detectorPanelWidth, detectorPanelHeight, detectorPanelThickness), lightGrayMat);
      sideDetectorArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), lightGrayMat);
      sideDetectorShortArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, sideDetectorOffsetX, 16), lightGrayMat);
      gantryRotatingAssembly.add(sideDetectorPanel, sideDetectorArm, sideDetectorShortArm);

      kvTubeGroup = new THREE.Group();
      kvTubeHousing = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.5, 20), metallicGrayMat);
      kvTubeHead = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.12, 0.1, 20), mediumGrayMat);
      kvTubeHead.position.y = 0.25;
      kvTubeGroup.add(kvTubeHousing, kvTubeHead);
      kvTubeLongArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, 1, 16), lightGrayMat);
      kvTubeShortArm = new THREE.Mesh(new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, sideDetectorOffsetX, 16), lightGrayMat);
      gantryRotatingAssembly.add(kvTubeGroup, kvTubeLongArm, kvTubeShortArm);
      setSideDetectorState(false);

      // Electron cone (toggle)
      const coneMaterial = new THREE.MeshStandardMaterial({ color: 0x808080, transparent: true, opacity: 0.6 });
      const coneHeight = 0.8;
      const coneSize = headSize * 0.7;
      electronCone = new THREE.Mesh(new THREE.BoxGeometry(coneSize, coneHeight, coneSize), coneMaterial);
      electronCone.position.set(0, -(headSize / 2) - (coneHeight / 2), 0);
      head.add(electronCone);
      electronCone.visible = false;

      // Klystron & waveguides
      klystron = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.6, 0.4), klystronMat);
      klystron.position.set(0, groundY + 0.3, drivestand.position.z);
      gantrySetupGroup.add(klystron);
      enableShadows(klystron);
    }

    // ---- Couch ----
    function buildCouch() {
      couchGroup = new THREE.Group(); window.couchGroup = couchGroup;
      const initialCouchY = (couchBaseHeight/2) + groundY; 
      couchGroup.position.set(0, initialCouchY, (ISO ? ISO.z : gantryPlaneZTarget) + couchSeparationOffset);
      scene.add(couchGroup); enableShadows(couchGroup);

      couchSupportBase = new THREE.Mesh(new THREE.BoxGeometry(couchWidth * 0.8, couchBaseHeight, couchLength * 0.5), lightBeigeMat);
      couchSupportBase.position.y = 0; couchGroup.add(couchSupportBase);

      couchTopGroup = new THREE.Group(); window.couchTopGroup = couchTopGroup;
      couchTopGroup.position.y = (couchBaseHeight/2) + (couchPlatformHeight/2); couchTopGroup.position.z = 0; couchGroup.add(couchTopGroup);

      couchPlatform = new THREE.Mesh(new THREE.BoxGeometry(couchWidth, couchPlatformHeight, couchLength), mediumGrayMat);
      couchTopGroup.add(couchPlatform);

      // Pendant (visual)
      const pendantHeight = 0.3, wireLength = 0.3; const pendantGeo = new THREE.BoxGeometry(0.2, pendantHeight, 0.04);
      const wireGeo = new THREE.CylinderGeometry(0.01, 0.01, wireLength, 8);
      const handPendant = new THREE.Mesh(pendantGeo, darkGrayMatMaterial); const pendantWire = new THREE.Mesh(wireGeo, darkGrayMatMaterial);
      const couchBaseFootZ = (couchLength*0.5)/2; const couchBaseTopY = couchBaseHeight/2;
      handPendant.position.set(0, couchBaseTopY + (pendantHeight/2) - 0.02, couchBaseFootZ); pendantWire.position.set(0, couchBaseTopY - (wireLength/2), couchBaseFootZ);
      couchGroup.add(handPendant); couchGroup.add(pendantWire);

      // Accordion
      couchAccordion = new THREE.Group(); couchAccordion.position.set(couchGroup.position.x, groundY, couchGroup.position.z); scene.add(couchAccordion); enableShadows(couchAccordion);
      couchAccordionVisual = new THREE.Mesh(new THREE.BoxGeometry(couchWidth * 0.7, accordionGeometricHeight, couchLength * 0.4), darkGrayMatMaterial);
      couchAccordionVisual.position.y = accordionGeometricHeight/2; couchAccordion.add(couchAccordionVisual); updateAccordion();
    }

    // ---- Patient Model (head-first supine) ----
    function buildPatient() {
      patientModel = new THREE.Group();
      couchTopGroup.add(patientModel);

      // Build simplified HFS anatomy scaled to couch
      const torso = new THREE.Mesh(new THREE.CylinderGeometry(0.28, 0.26, 0.75, 20), patientMat); torso.castShadow = true; patientModel.add(torso);
      const neck  = new THREE.Mesh(new THREE.CylinderGeometry(0.10, 0.10, 0.12, 16), patientMat); neck.position.set(0, 0.75/2 + 0.08, 0); patientModel.add(neck);
      const headS = new THREE.Mesh(new THREE.SphereGeometry(0.14, 20, 20), patientMat); headS.position.set(0, neck.position.y + 0.12, 0); headS.scale.set(0.8, 1, 1); patientModel.add(headS);
      const armGeo = new THREE.CylinderGeometry(0.07, 0.06, 0.70, 12);
      const leftArm = new THREE.Mesh(armGeo, patientMat); leftArm.position.set(-0.32, 0.0, 0); patientModel.add(leftArm);
      const rightArm= new THREE.Mesh(armGeo, patientMat); rightArm.position.set( 0.32, 0.0, 0); patientModel.add(rightArm);
      const legGeo = new THREE.CylinderGeometry(0.12, 0.09, 0.85, 12);
      const leftLeg = new THREE.Mesh(legGeo, patientMat); leftLeg.position.set(-0.12, -0.85, 0); patientModel.add(leftLeg);
      const rightLeg= new THREE.Mesh(legGeo, patientMat); rightLeg.position.set( 0.12, -0.85, 0); patientModel.add(rightLeg);

      // Tumor & tattoos (relative to patient)
      tumor = new THREE.Mesh(new THREE.SphereGeometry(0.05, 24, 24), tumorMat); tumor.renderOrder = 2; patientModel.add(tumor);
      const tatGeo = new THREE.SphereGeometry(0.012, 12, 12);
      tattooAnterior = new THREE.Mesh(tatGeo, tattooMat); tattooLeft = new THREE.Mesh(tatGeo, tattooMat); tattooRight = new THREE.Mesh(tatGeo, tattooMat);
      [tattooAnterior, tattooLeft, tattooRight].forEach(t => { t.renderOrder = 3; patientModel.add(t); });

      // Orientation: lay patient supine (long axis along +Z toward feet)
      patientModel.rotation.x = -Math.PI/2; // turn to lie on back along couch Z
      
      const patientOnCouchY = (couchPlatformHeight / 2) + 0.28 + 0.01;
      patientModel.position.set(0, patientOnCouchY, 0.0);
    }

    // ---- Room Lasers at ISO ----
    function buildLasers() {
      const laserMaterial = new THREE.MeshBasicMaterial({ color: 0xff0000, depthTest: false, transparent: true, opacity: 0.95 });
      const laserLen = 30, laserRadius = 0.01;
      const geo = new THREE.CylinderGeometry(laserRadius, laserRadius, laserLen, 8);

      const laserX = new THREE.Mesh(geo, laserMaterial); laserX.rotation.z = Math.PI/2; laserX.position.copy(ISO); scene.add(laserX);
      const laserY = new THREE.Mesh(geo, laserMaterial); laserY.position.copy(ISO); scene.add(laserY);
      const laserZ = new THREE.Mesh(geo, laserMaterial); laserZ.rotation.x = Math.PI/2; laserZ.position.copy(ISO); scene.add(laserZ);
      [laserX, laserY, laserZ].forEach(l => { l.renderOrder = 10; });
    }

    // ---- Labels ----
    function hookLabels() {
      const ids = ['drivestand','acceleratorHousing','verticalArmL','head','couchBase','couchTop','couchAccordion','detectorPanel','sideDetectorPanel','kvTube','electronCone','handPendant','axisX','axisY','axisZ','electronGun','waveguide','target','klystron','klystronWaveguide'];
      ids.forEach(id => labels[id] = document.getElementById('label-'+id));

      const xAxisLabelObj = new THREE.Object3D(); xAxisLabelObj.position.set(3.2,0,0); scene.add(xAxisLabelObj);
      const yAxisLabelObj = new THREE.Object3D(); yAxisLabelObj.position.set(0,3.2,0); scene.add(yAxisLabelObj);
      const zAxisLabelObj = new THREE.Object3D(); zAxisLabelObj.position.set(0,0,3.2); scene.add(zAxisLabelObj);

      // Register objects to labels
      labeledObjects.push({ object: drivestand, label: labels.drivestand });
      labeledObjects.push({ object: acceleratorHousing, label: labels.acceleratorHousing });
      labeledObjects.push({ object: verticalArmL, label: labels.verticalArmL });
      labeledObjects.push({ object: head, label: labels.head });
      labeledObjects.push({ object: couchSupportBase, label: labels.couchBase });
      labeledObjects.push({ object: couchPlatform, label: labels.couchTop });
      labeledObjects.push({ object: couchAccordionVisual, label: labels.couchAccordion });
      labeledObjects.push({ object: detectorPanel, label: labels.detectorPanel });
      labeledObjects.push({ object: sideDetectorPanel, label: labels.sideDetectorPanel });
      labeledObjects.push({ object: kvTubeHousing, label: labels.kvTube });
      labeledObjects.push({ object: electronCone, label: labels.electronCone });
      labeledObjects.push({ object: xAxisLabelObj, label: labels.axisX });
      labeledObjects.push({ object: yAxisLabelObj, label: labels.axisY });
      labeledObjects.push({ object: zAxisLabelObj, label: labels.axisZ });
      labeledObjects.push({ object: electronGun, label: labels.electronGun });
      labeledObjects.push({ object: waveguide, label: labels.waveguide });
      labeledObjects.push({ object: target, label: labels.target });
      labeledObjects.push({ object: klystron, label: labels.klystron });
      
      updateAllLabelVisibility();
    }

    // ===== Alignment logic =====
    function newCase() {
      // Random tumor local offset within torso size
      tumorLocalOffset.set((Math.random()-0.5)*0.12, (Math.random()-0.2)*0.40, (Math.random()-0.5)*0.12);
      tumor.position.copy(tumorLocalOffset);

      // Tattoos approx. triad around tumor
      const torsoParams = { height: 0.75, radiusTop: 0.28, radiusBottom: 0.26 };
      const y_norm = (tumorLocalOffset.y + torsoParams.height/2) / torsoParams.height;
      const radiusAtY = torsoParams.radiusBottom + (torsoParams.radiusTop - torsoParams.radiusBottom) * y_norm;
      tattooAnterior.position.set(tumorLocalOffset.x, tumorLocalOffset.y, radiusAtY);
      tattooLeft.position.set(-radiusAtY, tumorLocalOffset.y, tumorLocalOffset.z);
      tattooRight.position.set(radiusAtY, tumorLocalOffset.y, tumorLocalOffset.z);

      // Slight random couch offsets to start (simulate initial setup)
      couchTopGroup.position.x = (Math.random()-0.5) * 0.20;     // ±10 cm lateral
      couchTopGroup.position.z = (Math.random()-0.5) * 0.30;     // ±15 cm long
      couchGroup.position.y    = (couchBaseHeight/2) + groundY + 0.20 + Math.random()*0.20; // 20–40 cm up

      alignmentMessageElement.style.color = '#333';
      alignmentMessageElement.textContent = 'New case loaded. Use couch and nudge controls, then Check Alignment.';
    }

    function nudgePatient(dx, dy, dz) {
      // Fine nudges apply to couchTopGroup (x,z) and couchGroup (y)
      couchTopGroup.position.x += dx * MOVE_STEP;
      couchGroup.position.y    += dy * MOVE_STEP;
      couchTopGroup.position.z += dz * MOVE_STEP;
      constrainCouch();
    }

    function centerCouch() {
      couchTopGroup.position.x = 0;
      couchTopGroup.position.z = 0;
      
      const worldPosOfCouchTopGroup = couchGroup.position.y + couchTopGroup.position.y;
      const worldPosOfCouchSurface = worldPosOfCouchTopGroup + (couchPlatformHeight / 2);
      const requiredShift = ISO.y - worldPosOfCouchSurface;
      
      couchGroup.position.y += requiredShift;
      
      constrainCouch(); // Apply limits and update visuals
    }

    function checkAlignment() {
      // World position of tumor
      const tumorWorld = new THREE.Vector3(); tumor.getWorldPosition(tumorWorld);
      const dist = tumorWorld.distanceTo(ISO);

      const shift = new THREE.Vector3().subVectors(ISO, tumorWorld); // required couch shift
      const msg = (dist < ALIGNMENT_TOLERANCE)
        ? `Alignment OK! Tumor at isocenter within ${(dist*100).toFixed(1)} mm.`
        : `Tumor is ${(dist*100).toFixed(1)} mm from ISO. Required Shifts → Lateral X: ${shift.x.toFixed(3)} m, Vertical Y: ${shift.y.toFixed(3)} m, Longitudinal Z: ${shift.z.toFixed(3)} m`;
      alignmentMessageElement.innerHTML = msg;
      alignmentMessageElement.style.color = (dist < ALIGNMENT_TOLERANCE) ? 'green' : 'crimson';
    }

    // ===== LINAC Interactions =====
    window.toggleLabels = function() { labelsVisible = !labelsVisible; if (!labelsVisible) hideAllLabels(); else updateAllLabelVisibility(); };

    window.rotateGantry = function(clockwise = true) { const direction = clockwise ? 1 : -1; window.gantryRotatingAssembly.rotation.z += direction * 0.05; };

    window.adjustJaws = function(open = true) { const delta = open ? 0.02 : -0.02; setJawOffset(THREE.MathUtils.clamp(jawOffset + delta, 0.03, headSize*0.4)); };

    window.moveCouch = function(up = true) {
      couchGroup.position.y += up ? 0.01*10 : -0.01*10; // 1 cm step *10
      constrainCouch();
    };

    window.moveCouchLongitudinal = function(towardsGantry = true) {
      const dir = towardsGantry ? -1 : 1; couchTopGroup.position.z += dir * 0.01 * 10; // 1 cm
      constrainCouch();
    };

    window.moveCouchLateral = function(left = true) {
      const dir = left ? 1 : -1; couchTopGroup.position.x += dir * 0.01 * 10; // 1 cm
      constrainCouch();
    };

    function setDetectorState(isExtended) {
        detectorExtended = isExtended;
        const verticalArmBottomY = -newVerticalArmTotalLength / 2;
        const headZ = head.position.z;

        if (isExtended) {
            detectorArm.visible = true;
            const armLen = headZ;
            detectorArm.geometry.dispose();
            detectorArm.geometry = new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, armLen, 16);
            detectorArm.rotation.set(0, 0, Math.PI / 2);
            detectorArm.position.set(0, verticalArmBottomY, armLen / 2);
            detectorPanel.rotation.set(Math.PI / 2, 0, 0);
            detectorPanel.position.set(0, verticalArmBottomY, headZ);
        } else {
            detectorArm.visible = false;
            detectorPanel.rotation.set(0, 0, 0);
            detectorPanel.position.set(0, verticalArmBottomY + detectorPanelHeight / 2, verticalArmLSize / 2 + detectorPanelThickness / 2);
        }
        const b = document.getElementById('detectorToggleButton');
        if (b) b.textContent = detectorExtended ? 'Retract kV Detector (AP)' : 'Extend kV Detector (AP)';
    }


    function setSideDetectorState(isExtended) {
        sideDetectorExtended = isExtended;
        const headZ = head.position.z;
        const gantryArmLeftX = -verticalArmLSize / 2;
        const gantryArmRightX = verticalArmLSize / 2;

        if (isExtended) {
            sideDetectorShortArm.visible = sideDetectorArm.visible = kvTubeShortArm.visible = kvTubeLongArm.visible = kvTubeGroup.visible = true;
            const armLen = headZ;
            sideDetectorArm.geometry.dispose();
            sideDetectorArm.geometry = new THREE.CylinderGeometry(detectorArmRadius, detectorArmRadius, armLen, 16);
            sideDetectorShortArm.rotation.set(0, 0, Math.PI / 2);
            sideDetectorShortArm.position.set(gantryArmLeftX - sideDetectorOffsetX / 2, 0, 0);
            sideDetectorArm.rotation.set(Math.PI / 2, 0, 0);
            sideDetectorArm.position.set(gantryArmLeftX - sideDetectorOffsetX, 0, armLen / 2);
            sideDetectorPanel.rotation.set(0, -Math.PI / 2, 0);
            sideDetectorPanel.position.set(gantryArmLeftX - sideDetectorOffsetX, 0, headZ);

            kvTubeShortArm.rotation.set(0, 0, Math.PI / 2);
            kvTubeShortArm.position.set(gantryArmRightX + sideDetectorOffsetX / 2, 0, 0);
            kvTubeLongArm.rotation.set(Math.PI / 2, 0, 0);
            kvTubeLongArm.position.set(gantryArmRightX + sideDetectorOffsetX, 0, armLen / 2);
            kvTubeGroup.rotation.set(Math.PI / 2, 0, 0);
            kvTubeGroup.position.set(gantryArmRightX + sideDetectorOffsetX, 0, headZ);
        } else {
            sideDetectorShortArm.visible = sideDetectorArm.visible = kvTubeShortArm.visible = kvTubeLongArm.visible = kvTubeGroup.visible = false;
            sideDetectorPanel.rotation.set(0, Math.PI / 2, 0);
            sideDetectorPanel.position.set(gantryArmLeftX - (detectorPanelHeight / 2), 0, detectorPanelWidth / 2);
        }
        const b = document.getElementById('sideDetectorToggleButton');
        if (b) b.textContent = sideDetectorExtended ? 'Retract Side Imagers (Lat)' : 'Extend Side Imagers (Lat)';
    }


    window.toggleElectronCone = function() {
      isConeAttached = !isConeAttached; electronCone.visible = isConeAttached;
      const b = document.getElementById('coneToggleButton'); if (b) b.textContent = isConeAttached ? 'Remove Electron Cone' : 'Attach Electron Cone';
    };

    // Helpers
    function setJawOffset(val){ jawOffset = val; jawXN_new.position.x = -jawOffset; jawXP_new.position.x = jawOffset; jawZN_new.position.z = -jawOffset; jawZP_new.position.z = jawOffset; }
    function updateAccordion(){ const baseBottomWorldY = couchGroup.position.y - (couchBaseHeight/2); const h = Math.max(0.01, baseBottomWorldY - groundY); couchAccordionVisual.scale.y = h; couchAccordionVisual.position.y = accordionGeometricHeight/2; couchAccordion.position.x = couchGroup.position.x; couchAccordion.position.z = couchGroup.position.z; }
    function constrainCouch(){ 
        const minY = (couchBaseHeight/2) + groundY; 
        const maxY = isocenterYTarget + 0.2; 
        couchGroup.position.y = THREE.MathUtils.clamp(couchGroup.position.y, minY, maxY); 
        
        const zExt = couchLength*0.5; 
        const xExt = couchWidth*0.4; 
        couchTopGroup.position.z = THREE.MathUtils.clamp(couchTopGroup.position.z, -zExt, zExt); 
        couchTopGroup.position.x = THREE.MathUtils.clamp(couchTopGroup.position.x, -xExt, xExt); 
        updateAccordion(); 
    }
    function enableShadows(o){ o.castShadow = true; o.receiveShadow = true; if (o.children) o.children.forEach(enableShadows); }

    // Label math
    function updateAllLabelVisibility(){ labeledObjects.forEach(({object,label})=>updateLabelPosition(label, object)); }
    function hideAllLabels(){ labeledObjects.forEach(({label})=>{ if(label) label.style.visibility='hidden'; }); }
    function updateLabelPosition(labelElement, object3D){ if(!labelElement || !object3D) return; if (!labelsVisible){ labelElement.style.visibility='hidden'; return; } const tempV = new THREE.Vector3(); scene.updateMatrixWorld(true); object3D.getWorldPosition(tempV); tempV.project(camera); const x = (tempV.x * .5 + .5) * renderer.domElement.clientWidth; const y = (tempV.y * -.5 + .5) * renderer.domElement.clientHeight; const objectWorldPosition = new THREE.Vector3(); object3D.getWorldPosition(objectWorldPosition); const cameraDirection = new THREE.Vector3(); camera.getWorldDirection(cameraDirection); const objectDirection = new THREE.Vector3().subVectors(objectWorldPosition, camera.position); if (objectDirection.dot(cameraDirection) > 0 && tempV.z < 1 && tempV.z > -1){ labelElement.style.transform = `translate(-50%, -110%) translate(${x}px,${y}px)`; labelElement.style.visibility = 'visible'; } else { labelElement.style.visibility = 'hidden'; } }

    // Window & render loop
    function onWindowResize(){ camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); updateAllLabelVisibility(); }
    function animate(){ requestAnimationFrame(animate); controls.update(); if (labelsVisible) updateAllLabelVisibility(); renderer.render(scene, camera); }

    // Drag utility for panels
    function makeDraggable(element){ let pos1=0,pos2=0,pos3=0,pos4=0; const header=document.getElementById(element.id+"-header")||element; header.onmousedown=dragMouseDown; function dragMouseDown(e){ e=e||window.event; e.preventDefault(); pos3=e.clientX; pos4=e.clientY; document.onmouseup=closeDragElement; document.onmousemove=elementDrag; } function elementDrag(e){ e=e||window.event; e.preventDefault(); pos1=pos3-e.clientX; pos2=pos4-e.clientY; pos3=e.clientX; pos4=e.clientY; element.style.top=(element.offsetTop - pos2)+"px"; element.style.left=(element.offsetLeft - pos1)+"px"; } function closeDragElement(){ document.onmouseup=null; document.onmousemove=null; } }

    // Expose alignment functions
    window.newCase = newCase;
    window.nudgePatient = nudgePatient;
    window.centerCouch = centerCouch;
    window.checkAlignment = checkAlignment;
  </script>
</body>
</html>
